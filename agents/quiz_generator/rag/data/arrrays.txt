# МАССИВЫ В ЯЗЫКЕ C - ПОЛНОЕ РУКОВОДСТВО

## 1. ОСНОВЫ МАССИВОВ

### Определение и объявление
Массив — это упорядоченная коллекция элементов одного типа данных, хранящихся в памяти рядом друг с другом.

Синтаксис объявления одномерного массива:тип_данных имя_массива[размер];

Примеры:int numbers[5];           // Массив из 5 целых чисел
float grades[10];         // Массив из 10 вещественных чисел
char letters[26];         // Массив из 26 символов
double data[100];         // Массив из 100 вещественных чисел двойной точности

### Инициализация массивов
Массив можно инициализировать при объявлении:
// Инициализация с указанием всех элементов
int numbers[] = {1, 2, 3, 4, 5};

// Инициализация частью элементов (остальные = 0)
int arr[5] = {10, 20, 30};  // {10, 20, 30, 0, 0}

// Инициализация глобального массива (все элементы = 0)
int global_arr[100];  // все элементы инициализированы нулями

// Локальный массив (содержит мусор без инициализации)
int local_arr[100];   // ⚠️ Содержит случайные значения!

// Явная инициализация нулями
int arr[50] = {0};    // все элементы = 0

### Размер массива
Размер массива должен быть известен на этапе компиляции или используется динамическое выделение памяти.
#define MAX_SIZE 100
int arr[MAX_SIZE];

// Определение количества элементов
int numbers[] = {1, 2, 3, 4, 5};
int length = sizeof(numbers) / sizeof(numbers[0]);  // = 5

## 2. ИНДЕКСАЦИЯ И ДОСТУП

### Нулевая индексация
В C индексация массивов начинается с 0!
int arr[5] = {10, 20, 30, 40, 50};
arr[0] = 10   // первый элемент
arr[1] = 20   // второй элемент
arr[2] = 30   // третий элемент
arr[3] = 40   // четвёртый элемент
arr[4] = 50   // пятый элемент
arr[5] = ???  // ⚠️ ВЫХОД ЗА ГРАНИЦЫ МАССИВА!

### Доступ к элементамint arr[5] = {10, 20, 30, 40, 50};

// Чтение элементов
printf("%d\n", arr[0]);      // Выводит: 10
printf("%d\n", arr[4]);      // Выводит: 50
int x = arr[2];              // x = 30

// Изменение элементов
arr[0] = 100;                // Меняем первый элемент
arr[2] = arr[2] + 5;         // Увеличиваем третий на 5
arr[3] *= 2;                 // Умножаем четвёртый на 2

### Арифметика указателей и массивы
Имя массива — это указатель на первый элемент:
int arr[5] = {10, 20, 30, 40, 50};

arr[i] == *(arr + i)         // Эквивалентные выражения
&arr[0] == arr               // Адрес первого элемента

int *ptr = arr;              // ptr указывает на начало массива
printf("%d\n", *ptr);        // Выводит: 10
printf("%d\n", *(ptr + 1));  // Выводит: 20
printf("%d\n", ptr[2]);      // Выводит: 30

## 3. ДВУМЕРНЫЕ МАССИВЫ

### Объявление двумерного массиватип_данных имя[строки][столбцы];

Примеры:int matrix[3][4];           // Матрица 3х4
float table[5][5];          // Квадратная матрица 5х5
char grid[10][10];          // Сетка 10х10

### Инициализация двумерного массива// Инициализация явно
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

// Инициализация по частям
int arr[3][3] = {
    {1, 2, 3},
    {4, 5},      // Остальные будут 0: {4, 5, 0}
    {7}          // Остальные будут 0: {7, 0, 0}
};

// Все элементы = 0
int matrix[2][3] = {{0}};

### Доступ к элементам двумерного массиваint matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

matrix[0][0] = 1   // первый элемент первой строки
matrix[0][1] = 2   // второй элемент первой строки
matrix[0][2] = 3   // третий элемент первой строки
matrix[1][0] = 4   // первый элемент второй строки
matrix[1][1] = 5   // второй элемент второй строки
matrix[1][2] = 6   // третий элемент второй строки

// Изменение элемента
matrix[1][2] = 100;

// Чтение элемента
int value = matrix[0][1];  // value = 2

### Порядок хранения в памяти
Двумерный массив хранится в памяти по строкам (row-major order):
int matrix[2][3] = {
    {1, 2, 3},
    {4, 5, 6}
};

// В памяти хранится как одномерный: [1, 2, 3, 4, 5, 6]
// matrix[i][j] = *(matrix + i*3 + j)

### Указатели на двумерные массивыint matrix[2][3];

int *ptr1 = (int *)matrix;           // Указатель на элемент
int (*ptr2)[3] = matrix;             // Указатель на строку (int[3])

int (*ptr3)[2][3] = &matrix;         // Указатель на весь массив

// Различные способы доступа:
matrix[1][2]
*(*(matrix + 1) + 2)
ptr1[5]                              // Линейный доступ
ptr2[1][2]                           // Через указатель на строку

## 4. ТРЁХМЕРНЫЕ И МНОГОМЕРНЫЕ МАССИВЫ

### Объявление трёхмерного массиваint cube[2][3][4];           // 3D массив размером 2х3х4

// Инициализация
int arr[2][2][2] = {
    {
        {1, 2},
        {3, 4}
    },
    {
        {5, 6},
        {7, 8}
    }
};

### Доступ к элементам трёхмерного массиваint cube[2][3][4];

cube[0][0][0] = 10;
cube[1][2][3] = 20;
int value = cube[0][1][2];

// Размер в памяти
int size = sizeof(cube) / sizeof(int);  // = 2*3*4 = 24

### Общий случай: многомерные массивыint arr4D[2][3][4][5];       // 4D массив

// Доступ:
arr4D[i][j][k][l]

// Размер в памяти:
int size = 2 * 3 * 4 * 5 = 120 элементов

## 5. МАССИВЫ И ФУНКЦИИ

### Передача одномерного массива в функцию// Способ 1: как указатель
void printArray(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Способ 2: как массив (эквивалентно указателю)
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
}

// Вызов:
int numbers[5] = {1, 2, 3, 4, 5};
printArray(numbers, 5);      // Массив передаётся по ссылке!

### Передача двумерного массива в функцию// ✅ ПРАВИЛЬНО: указываем количество столбцов
void printMatrix(int matrix[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

// ❌ НЕПРАВИЛЬНО: не указано количество столбцов
void printMatrix(int **matrix, int rows, int cols) {
    // Это не работает для 2D массивов!
}

// Вызов:
int matrix[2][3] = {{1,2,3}, {4,5,6}};
printMatrix(matrix, 2);

### Передача трёхмерного массива в функциюvoid process3D(int arr[][2][3], int dim1) {
    for (int i = 0; i < dim1; i++) {
        for (int j = 0; j < 2; j++) {
            for (int k = 0; k < 3; k++) {
                arr[i][j][k] += 1;
            }
        }
    }
}

// Вызов:
int cube[2][2][3];
process3D(cube, 2);

### Возврат массива из функции
⚠️ В C нельзя напрямую вернуть массив! Используются другие подходы:
// ❌ НЕПРАВИЛЬНО: нельзя вернуть локальный массив
int *getArray() {
    int arr[5] = {1, 2, 3, 4, 5};
    return arr;  // ⚠️ arr выходит из области видимости!
}

// ✅ ПРАВИЛЬНО 1: вернуть динамический массив
int *getArray() {
    int *arr = (int *)malloc(5 * sizeof(int));
    arr[0] = 1; arr[1] = 2; arr[2] = 3; arr[3] = 4; arr[4] = 5;
    return arr;  // Память остаётся выделена!
}

// ✅ ПРАВИЛЬНО 2: передать массив по ссылке
void fillArray(int *arr, int size) {
    for (int i = 0; i < size; i++) {
        arr[i] = i + 1;
    }
}

## 6. ДИНАМИЧЕСКИЕ МАССИВЫ

### Выделение памяти для динамического массива// Выделение памяти для одномерного массива
int *arr = (int *)malloc(n * sizeof(int));

// Инициализация нулями (calloc вместо malloc)
int *arr = (int *)calloc(n, sizeof(int));

// После использования обязательно освободить память
free(arr);

### Пример: динамический одномерный массив#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("Введите размер массива: ");
    scanf("%d", &n);

    // Выделение памяти
    int *arr = (int *)malloc(n * sizeof(int));

    if (arr == NULL) {
        printf("Ошибка выделения памяти!\n");
        return 1;
    }

    // Заполнение
    for (int i = 0; i < n; i++) {
        arr[i] = i + 1;
    }

    // Использование
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // Освобождение памяти
    free(arr);

    return 0;
}

### Динамический двумерный массив// Способ 1: массив указателей
int rows = 3, cols = 4;
int **matrix = (int **)malloc(rows * sizeof(int *));
for (int i = 0; i < rows; i++) {
    matrix[i] = (int *)malloc(cols * sizeof(int));
}

// Использование
matrix[i][j] = 10;

// Освобождение

for (int i = 0; i < rows; i++) {
    free(matrix[i]);
}
free(matrix);

// Способ 2: одна блок памяти
int *matrix = (int *)malloc(rows * cols * sizeof(int));
// Доступ: matrix[i * cols + j]
free(matrix);

## 7. СТРОКИ КАК МАССИВЫ СИМВОЛОВ

### Объявление строк// Строка как массив символов
char str[50];                    // Массив для строки из 49 символов + '\0'
char str[] = "Hello";           // Инициализация строки
char *str = "Hello";            // Указатель на строку (read-only)

### Копирование строкchar source[] = "Hello";
char dest[50];

// ❌ НЕПРАВИЛЬНО: копирует адрес, а не содержимое
dest = source;  // ⚠️ Ошибка компиляции!

// ✅ ПРАВИЛЬНО 1: strcpy (нужна проверка размера!)
strcpy(dest, source);

// ✅ ПРАВИЛЬНО 2: strncpy (безопаснее)
strncpy(dest, source, sizeof(dest) - 1);
dest[sizeof(dest) - 1] = '\0';

### Операции над строкамиchar str1[50] = "Hello";
char str2[50] = "World";

// strlen: длина строки
int len = strlen(str1);  // = 5 (без '\0')

// strcmp: сравнение строк
if (strcmp(str1, str2) == 0) {
    printf("Строки одинаковые\n");
}

// strcat: конкатенация
strcat(str1, " ");
strcat(str1, str2);      // str1 = "Hello World"

// strchr: поиск символа
char *pos = strchr(str1, 'o');
if (pos != NULL) {
    printf("Найден на позиции %ld\n", pos - str1);
}

## 8. АЛГОРИТМЫ СОРТИРОВКИ МАССИВОВ

### Сортировка пузырьком (Bubble Sort)void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // Обмен элементов
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

### Сортировка вставками (Insertion Sort)void insertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

### Сортировка выбором (Selection Sort)void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;

        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }

        // Обмен
        int temp = arr[i];
        arr[i] = arr[minIdx];
        arr[minIdx] = temp;
    }
}

### Встроенная функция qsort#include <stdlib.h>

// Функция сравнения
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);  // По возрастанию
}

// Использование
int arr[] = {5, 2, 8, 1, 9, 3};
qsort(arr, 6, sizeof(int), compare);

## 9. ПОИСК В МАССИВАХ

### Линейный поискint linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;  // Найден
        }
    }
    return -1;  // Не найден
}

### Бинарный поиск (для отсортированного массива)int binarySearch(int arr[], int n, int target) {
    int left = 0, right = n - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target) {
            return mid;
        }
        else if (arr[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }

    return -1;  // Не найден
}

## 10. ТИПИЧНЫЕ ОШИБКИ С МАССИВАМИ

### Ошибка 1: Выход за границы массиваint arr[5];
int x = arr[10];     // ⚠️ Undefined Behavior!
arr[10] = 100;       // ⚠️ Может привести к краху!

### Ошибка 2: Неинициализированные локальные массивыint arr[10];         // ⚠️ Содержит мусор!
for (int i = 0; i < 10; i++) {
    printf("%d\n", arr[i]);  // Случайные значения
}

// ✅ Правильно:
int arr[10] = {0};   // Инициализирована нулями

### Ошибка 3: Потеря указателя на динамический массивint *arr = (int *)malloc(100 * sizeof(int));
arr = NULL;          // ⚠️ Память не освобождена! Memory Leak!
free(arr);           // Пытается освободить NULL

// ✅ Правильно:
free(arr);
arr = NULL;

### Ошибка 4: Использование после освобождения памятиint *arr = (int *)malloc(100 * sizeof(int));
free(arr);
arr[0] = 10;         // ⚠️ Use-After-Free! Undefined Behavior!

### Ошибка 5: Неправильная передача 2D массива в функциюvoid process(int **arr, int rows, int cols) {
    // ❌ Это работает только если arr — массив указателей
}

// ✅ Правильно:
void process(int arr[][5], int rows) {
    // Количество столбцов ОБЯЗАТЕЛЬНО в прямоугольных скобках!
}

## 11. ПРАКТИЧЕСКИЕ ПРИМЕРЫ

### Пример 1: Нахождение максимума в массивеint findMax(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

### Пример 2: Подсчёт элементов больше среднегоint countAboveAverage(int arr[], int n) {
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += arr[i];
    }

    float average = (float)sum / n;
    int count = 0;

    for (int i = 0; i < n; i++) {
        if (arr[i] > average) {
            count++;
        }
    }

    return count;
}

### Пример 3: Реверс массиваvoid reverseArray(int arr[], int n) {
    for (int i = 0; i < n / 2; i++) {
        int temp = arr[i];
        arr[i] = arr[n - 1 - i];
        arr[n - 1 - i] = temp;
    }
}

### Пример 4: Удаление дубликатовint removeDuplicates(int arr[], int n) {
    if (n <= 1) return n;

    int uniqueCount = 1;
    for (int i = 1; i < n; i++) {
        if (arr[i] != arr[i - 1]) {
            arr[uniqueCount] = arr[i];
            uniqueCount++;
        }
    }

    return uniqueCount;
}

### Пример 5: Суммирование элементов матрицыint sumMatrix(int matrix[][3], int rows) {
    int sum = 0;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            sum += matrix[i][j];
        }
    }
    return sum;
}

### Пример 6: Транспонирование матрицыvoid transposeMatrix(int matrix[][3], int rows, int cols,
                     int result[][rows]) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            result[j][i] = matrix[i][j];
        }
    }
}

### Пример 7: Перемешивание массива#include <time.h>

void shuffleArray(int arr[], int n) {
    srand(time(NULL));

    for (int i = n - 1; i > 0; i--) {
        int j = rand() % (i + 1);

        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}

## 12. МАССИВЫ СТРУКТУР

### Объявление массива структурstruct Student {
    char name[50];
    int age;
    float gpa;
};

// Массив структур
struct Student students[30];

// Инициализация
struct Student students[] = {
    {"Alice", 20, 3.8},
    {"Bob", 21, 3.5},
    {"Charlie", 20, 3.9}
};

### Доступ к элементам структур в массивеstruct Student students[3];

// Запись
students[0].age = 20;
strcpy(students[0].name, "Alice");

// Чтение
printf("%s: %d лет, средний балл %.2f\n",
       students[0].name,
       students[0].age,
       students[0].gpa);

// Через указатель
struct Student *ptr = students;
printf("%d\n", ptr->age);      // age первого студента
printf("%d\n", (ptr + 1)->age); // age второго студента

## 13. ПРОИЗВОДИТЕЛЬНОСТЬ И ОПТИМИЗАЦИЯ

### Сложность алгоритмов поиска и сортировки

| Алгоритм | Лучший случай | Средний | Худший | Память |
|----------|---------------|--------|-------|--------|
| Линейный поиск | O(1) | O(n) | O(n) | O(1) |
| Бинарный поиск | O(1) | O(log n) | O(log n) | O(1) |
| Bubble Sort | O(n) | O(n²) | O(n²) | O(1) |
| Selection Sort | O(n²) | O(n²) | O(n²) | O(1) |
| Insertion Sort | O(n) | O(n²) | O(n²) | O(1) |
| Quick Sort | O(n log n) | O(n log n) | O(n²) | O(log n) |
| Merge Sort | O(n log n) | O(n log n) | O(n log n) | O(n) |

### Советы по оптимизации
1. Используйте бинарный поиск для отсортированных массивов (O(log n) вместо O(n))
2. Избегайте повторных проверок границ в циклах
3. Используйте локальные переменные для часто обращаемых элементов
4. Выделяйте память один раз, а не многократно в цикле
5. Кэшируйте результаты вычислений

## 14. СТАНДАРТНЫЕ ФУНКЦИИ ДЛЯ РАБОТЫ С МАССИВАМИ

### Функция memset (заполнение памяти)#include <string.h>

int arr[100];
memset(arr, 0, sizeof(arr));  // Заполнить нулями

### Функция memcpy (копирование памяти)int source[5] = {1, 2, 3, 4, 5};
int dest[5];
memcpy(dest, source, sizeof(source));

### Функция qsort (быстрая сортировка)int compare(const void *a, const void *b) {
    return *(int *)a - *(int *)b;
}

int arr[] = {5, 2, 8, 1, 9};
qsort(arr, 5, sizeof(int), compare);

### Функция bsearch (бинарный поиск)int target = 8;
int *result = (int *)bsearch(&target, arr, 5, sizeof(int), compare);
if (result != NULL) {
    printf("Найден: %d\n", *result);
}

## КЛЮЧЕВЫЕ МОМЕНТЫ

✅ Массивы хранятся в памяти подряд
✅ Индексация начинается с 0
✅ Имя массива — это указатель на первый элемент
✅ Размер должен быть известен при объявлении статического массива
✅ Для динамических размеров используйте malloc/calloc
✅ ВСЕГДА проверяйте границы массива
✅ ВСЕГДА освобождайте выделенную память (free)
✅ ВСЕГДА инициализируйте локальные массивы
✅ Для 2D массивов в функциях указывайте количество столбцов