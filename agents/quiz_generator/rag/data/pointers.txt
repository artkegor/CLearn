УКАЗАТЕЛИ В ПРОГРАММИРОВАНИИ

================================================================================
1. ОСНОВНЫЕ ПОНЯТИЯ
================================================================================

1.1 ЧТО ТАКОЕ УКАЗАТЕЛЬ

Определение: Указатель - это переменная, которая хранит адрес памяти другой переменной.

Ключевые характеристики:
- Адрес памяти: указатель содержит числовое значение, представляющее адрес в памяти
- Размер: указатель обычно занимает 4 байта (32-бит система) или 8 байт (64-бит система)
- Тип: указатель связан с типом данных, на которые он указывает (int*, char*, float*)
- Разыменование: процесс получения значения по адресу, на который указывает указатель
- Адресация: процесс получения адреса переменной

Пример на C:
int x = 10;           // обычная переменная
int *ptr = &x;        // указатель на x (хранит адрес x)
printf("%d\n", *ptr); // выведет 10 (разыменование)
printf("%p\n", ptr);  // выведет адрес в памяти (например: 0x7fff5fbff8ac)

---

1.2 ОБЪЯВЛЕНИЕ УКАЗАТЕЛЯ

Синтаксис:
тип *имя_указателя;

Описание:
- тип: тип данных, на которые указывает указатель (int, char, float, struct и т.д.)
- * (звёздочка): указывает, что это указатель, а не обычная переменная
- имя_указателя: имя переменной-указателя

Примеры объявления:
int *ptr_int;         // указатель на int
char *ptr_char;       // указатель на char
float *ptr_float;     // указатель на float
double *ptr_double;   // указатель на double
int **ptr_ptr;        // указатель на указатель (double pointer)

Инициализация при объявлении:
int x = 5;
int *ptr = &x;        // инициализируем указатель адресом x

Инициализация нулевым указателем:
int *ptr = NULL;      // не указывает ни на что (безопасная инициализация)

---

1.3 ОПЕРАТОР АДРЕСА (&)

Определение: Оператор & возвращает адрес переменной в памяти.

Синтаксис:
&переменная

Описание:
- Возвращает адрес памяти переменной
- Используется для получения адреса переменной
- Результат является указателем на переменную
- Работает с переменными, не со значениями

Примеры:
int x = 10;
int *ptr = &x;        // ptr содержит адрес x

int y = 20;
printf("%p\n", &y);   // выведет адрес y (например: 0x7fff5fbff8ac)

char c = 'A';
char *pc = &c;        // pc указывает на c

---

1.4 ОПЕРАТОР РАЗЫМЕНОВАНИЯ (*)

Определение: Оператор * разыменования получает значение, на которое указывает указатель.

Синтаксис:
*указатель

Описание:
- Получает значение переменной, на которую указывает указатель
- Противоположность оператору &
- Требует, чтобы указатель был инициализирован (указывал на реальный адрес)
- Если использовать на неинициализированном указателе - undefined behavior

Примеры:
int x = 10;
int *ptr = &x;
printf("%d\n", *ptr); // выведет 10 (значение переменной x)

int y = 20;
int *py = &y;
*py = 30;             // изменяет значение y на 30
printf("%d\n", y);    // выведет 30

char c = 'A';
char *pc = &c;
printf("%c\n", *pc);  // выведет A

---

1.5 NULL УКАЗАТЕЛЬ

Определение: NULL указатель - это указатель, который не указывает ни на какой адрес памяти.

Описание:
- NULL обычно равен нулю (0x0 в памяти)
- Используется для инициализации указателя "ничем"
- Обязательно проверяйте, не NULL ли указатель, перед разыменованием
- Разыменование NULL указателя приводит к segmentation fault (краху программы)

Пример:
int *ptr = NULL;      // безопасно инициализировали NULL

if (ptr != NULL) {
    printf("%d\n", *ptr);  // разыменуем только если не NULL
}

// Опасно:
int *bad_ptr = NULL;
printf("%d\n", *bad_ptr);  // крах программы (segmentation fault)

================================================================================
2. ПАМЯТЬ И АДРЕСА
================================================================================

2.1 КАК ПАМЯТЬ РАБОТАЕТ В C

Память компьютера:
- Память - это линейный массив ячеек (байтов)
- Каждая ячейка имеет адрес (обычно шестнадцатеричное число)
- Каждая переменная занимает несколько ячеек в зависимости от типа
- Адреса растут от меньшего к большему (обычно снизу вверх)

Пример расположения в памяти:
Адрес      | Значение
-----------|----------
0x7fff500  | ?
0x7fff504  | 10        (переменная x: 4 байта, int)
0x7fff508  | 20        (переменная y: 4 байта, int)
0x7fff50c  | 'A'       (переменная c: 1 байт, char)
0x7fff50d  | ?

---

2.2 РАЗМЕР ТИПОВ И УКАЗАТЕЛЕЙ

Размер переменной:
- char: 1 байт
- short: 2 байта
- int: 4 байта (обычно)
- long: 4 или 8 байт
- float: 4 байта
- double: 8 байт

Размер указателя:
- На 32-битной системе: 4 байта
- На 64-битной системе: 8 байт
- Все указатели имеют одинаковый размер вне зависимости от типа

Пример:
int x = 10;
int *ptr = &x;
printf("Размер int: %lu\n", sizeof(int));      // обычно 4
printf("Размер указателя: %lu\n", sizeof(ptr)); // 4 или 8
printf("Адрес x: %p\n", &x);                    // печать адреса

---

2.3 СТЕК И КУЧА

Стек (Stack):
- Используется для локальных переменных и параметров функции
- Автоматически освобождается при выходе из области видимости
- Быстрее, но меньше памяти
- LIFO (Last In First Out) - последний вошёл, первый вышел

Куча (Heap):
- Используется для динамического выделения памяти
- Должна быть вручную освобождена
- Медленнее, но больше памяти доступно
- Остаётся в памяти до явного освобождения или конца программы

Пример:
void function() {
    int x = 10;              // на стеке
    int *ptr = malloc(sizeof(int)); // указатель на стеке, данные на куче
    *ptr = 20;
    
    free(ptr);               // освобождаем кучу
}                            // стек автоматически освобождается

================================================================================
3. ДИНАМИЧЕСКОЕ ВЫДЕЛЕНИЕ ПАМЯТИ
================================================================================

3.1 ФУНКЦИЯ MALLOC()

Определение: malloc() выделяет блок памяти на куче и возвращает указатель на него.

Синтаксис:
void *malloc(size_t size);

Описание:
- Выделяет size байт памяти на куче
- Возвращает указатель (void*) на выделенную память
- Возвращает NULL если выделение не удалось
- Память не инициализирована (содержит мусор)
- Необходимо явно освободить с помощью free()

Примеры:
int *ptr = malloc(sizeof(int));      // выделяем место для одного int
if (ptr == NULL) {
    printf("Ошибка выделения памяти\n");
    return;
}
*ptr = 42;
free(ptr);

int *arr = malloc(10 * sizeof(int)); // выделяем место для массива из 10 int
if (arr != NULL) {
    arr[0] = 100;
    arr[1] = 200;
    free(arr);
}

char *str = malloc(50 * sizeof(char)); // выделяем место для строки
if (str != NULL) {
    str = "Hello";
    free(str);
}

---

3.2 ФУНКЦИЯ CALLOC()

Определение: calloc() выделяет блок памяти и инициализирует его нулями.

Синтаксис:
void *calloc(size_t num, size_t size);

Описание:
- Выделяет num * size байт памяти
- Инициализирует всю память нулями (в отличие от malloc)
- Возвращает указатель на выделенную память
- Возвращает NULL если выделение не удалось
- Медленнее, чем malloc (из-за инициализации)

Примеры:
int *arr = calloc(10, sizeof(int)); // выделяем место для 10 int и инициализируем нулями
if (arr != NULL) {
    printf("arr[0] = %d\n", arr[0]); // выведет 0 (уже инициализировано)
    free(arr);
}

char *str = calloc(50, sizeof(char)); // выделяем место для строки, инициализируем \0
if (str != NULL) {
    printf("Длина строки: %lu\n", strlen(str)); // выведет 0
    free(str);
}

---

3.3 ФУНКЦИЯ REALLOC()

Определение: realloc() изменяет размер ранее выделенного блока памяти.

Синтаксис:
void *realloc(void *ptr, size_t size);

Описание:
- Изменяет размер блока памяти, на который указывает ptr
- Может переместить блок в другое место в памяти
- Возвращает указатель на новый блок памяти
- Если size = 0, ведёт себя как free()
- Возвращает NULL если операция не удалась (исходная память не освобождается)

Примеры:
int *arr = malloc(5 * sizeof(int));
arr[0] = 10;
arr[1] = 20;

// Нужно увеличить размер до 10 элементов
arr = realloc(arr, 10 * sizeof(int)); // arr теперь указывает на новый блок
if (arr != NULL) {
    arr[5] = 50;
    free(arr);
}

Правильная проверка при realloc:
int *ptr = malloc(100);
int *new_ptr = realloc(ptr, 200);
if (new_ptr != NULL) {
    ptr = new_ptr;  // обновляем указатель
} else {
    // realloc не удалась, но ptr всё ещё действительный
    free(ptr);
    return;
}

---

3.4 ФУНКЦИЯ FREE()

Определение: free() освобождает динамически выделенную память.

Синтаксис:
void free(void *ptr);

Описание:
- Освобождает память, выделенную malloc(), calloc() или realloc()
- Возвращает память операционной системе
- После free() указатель всё ещё содержит адрес (становится "повисшим" указателем)
- Разыменование после free() - undefined behavior
- Освобождение уже освобождённой памяти - undefined behavior

Примеры:
int *ptr = malloc(sizeof(int));
*ptr = 42;
free(ptr);
// ptr всё ещё содержит старый адрес, но память больше не выделена

Правильное использование:
int *ptr = malloc(sizeof(int));
if (ptr != NULL) {
    *ptr = 42;
    printf("%d\n", *ptr);
    free(ptr);
    ptr = NULL;  // хорошая практика: устанавливаем NULL после free()
}

Опасно:
int *ptr = malloc(sizeof(int));
free(ptr);
printf("%d\n", *ptr);  // undefined behavior - разыменование повисшего указателя

int *ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // undefined behavior - двойное освобождение

================================================================================
4. УКАЗАТЕЛИ И МАССИВЫ
================================================================================

4.1 СВЯЗЬ МЕЖДУ УКАЗАТЕЛЯМИ И МАССИВАМИ

Определение: Имя массива в C - это указатель на первый элемент массива.

Описание:
- arr[0] эквивалентен *arr (первый элемент)
- arr[i] эквивалентен *(arr + i) (i-й элемент)
- &arr[i] эквивалентен (arr + i) (адрес i-го элемента)
- Массив в памяти расположен подряд

Примеры:
int arr[5] = {10, 20, 30, 40, 50};

printf("%d\n", arr[0]);    // 10
printf("%d\n", *arr);      // 10 (тоже самое)

printf("%d\n", arr[2]);    // 30
printf("%d\n", *(arr + 2)); // 30 (тоже самое)

int *ptr = arr;            // ptr указывает на первый элемент
printf("%d\n", *ptr);      // 10
printf("%d\n", *(ptr + 3)); // 40

---

4.2 АРИФМЕТИКА УКАЗАТЕЛЕЙ

Определение: Арифметика указателей - операции сложения и вычитания с указателями.

Описание:
- ptr + n: смещение на n элементов (не на n байт!)
- ptr - n: смещение на n элементов в обратном направлении
- ptr++: переместить на следующий элемент
- ptr--: переместить на предыдущий элемент
- ptr1 - ptr2: разница между указателями (в элементах)

Примеры:
int arr[5] = {10, 20, 30, 40, 50};
int *ptr = arr;

printf("%d\n", *ptr);      // 10 (arr[0])
printf("%d\n", *(ptr + 1)); // 20 (arr[1])
printf("%d\n", *(ptr + 2)); // 30 (arr[2])

ptr++;
printf("%d\n", *ptr);      // 20 (теперь на arr[1])

ptr--;
printf("%d\n", *ptr);      // 10 (вернулись на arr[0])

int *ptr1 = &arr[1];
int *ptr2 = &arr[4];
printf("%d\n", ptr2 - ptr1); // 3 (разница в элементах)

---

4.3 ДИНАМИЧЕСКИЕ МАССИВЫ

Определение: Динамический массив - это массив, размер которого определяется во время выполнения программы.

Описание:
- Выделяется с помощью malloc() или calloc()
- Размер может быть переменной
- Доступ как к обычному массиву через []
- Необходимо явно освободить с помощью free()

Примеры:
int n = 10;  // размер определяется во время выполнения
int *arr = malloc(n * sizeof(int));
if (arr == NULL) {
    printf("Ошибка выделения памяти\n");
    return;
}

for (int i = 0; i < n; i++) {
    arr[i] = i * 10;
}

for (int i = 0; i < n; i++) {
    printf("%d ", arr[i]);
}

free(arr);

Альтернатива с calloc:
int *arr = calloc(10, sizeof(int));  // выделяем 10 целых чисел, инициализируем 0
if (arr != NULL) {
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);  // выведет нули
    }
    free(arr);
}

================================================================================
5. УКАЗАТЕЛИ НА ФУНКЦИИ И СТРУКТУРЫ
================================================================================

5.1 УКАЗАТЕЛИ НА СТРУКТУРЫ

Определение: Указатель на структуру - это переменная, которая хранит адрес структуры.

Синтаксис:
struct Имя *ptr_struct;

Описание:
- Позволяет передавать структуры функциям по ссылке
- Сохраняет память (передаём адрес, не копию структуры)
- Используется для доступа к полям структуры через ->
- Альтернатива: (*ptr_struct).поле

Пример:
struct Person {
    char name[50];
    int age;
    float height;
};

struct Person p = {"Alice", 25, 1.7};
struct Person *ptr = &p;

// Доступ к полям структуры
printf("Имя: %s\n", ptr->name);      // Alice
printf("Возраст: %d\n", ptr->age);   // 25
printf("Рост: %.1f\n", ptr->height); // 1.7

// Эквивалентно:
printf("Имя: %s\n", (*ptr).name);

// Изменение значений
ptr->age = 26;
printf("Новый возраст: %d\n", p.age); // 26 (изменилась оригинальная переменная)

---

5.2 ДИНАМИЧЕСКОЕ ВЫДЕЛЕНИЕ СТРУКТУР

Описание:
- Выделяем память для структуры с помощью malloc()
- Используем -> для доступа к полям
- Необходимо освободить память с помощью free()

Примеры:
struct Person *ptr = malloc(sizeof(struct Person));
if (ptr != NULL) {
    strcpy(ptr->name, "Bob");
    ptr->age = 30;
    ptr->height = 1.8;
    
    printf("Имя: %s, Возраст: %d\n", ptr->name, ptr->age);
    
    free(ptr);
}

Массив структур:
struct Person *people = malloc(3 * sizeof(struct Person));
if (people != NULL) {
    people[0].age = 25;
    people[1].age = 30;
    people[2].age = 35;
    
    // Или через указатель:
    (people + 0)->age = 25;
    (people + 1)->age = 30;
    
    free(people);
}

---

5.3 УКАЗАТЕЛИ НА ФУНКЦИИ

Определение: Указатель на функцию - это переменная, которая хранит адрес функции.

Синтаксис:
возвращаемый_тип (*имя_указателя)(параметры);

Описание:
- Позволяет вызывать функцию через указатель
- Используется для передачи функции как параметра
- Основа для callback функций и функциональных указателей

Пример:
int add(int a, int b) {
    return a + b;
}

int multiply(int a, int b) {
    return a * b;
}

int main() {
    // Объявляем указатель на функцию
    int (*operation)(int, int);
    
    // Инициализируем указатель на функцию add
    operation = add;
    printf("%d\n", operation(10, 20)); // 30
    
    // Переназначаем на функцию multiply
    operation = multiply;
    printf("%d\n", operation(10, 20)); // 200
    
    return 0;
}

---

5.4 МАССИВ УКАЗАТЕЛЕЙ НА ФУНКЦИИ

Описание:
- Можно создать массив указателей на функции
- Используется для создания таблиц функций (dispatch tables)

Пример:
int add(int a, int b) { return a + b; }
int sub(int a, int b) { return a - b; }
int mul(int a, int b) { return a * b; }
int div(int a, int b) { return a / b; }

int main() {
    int (*ops[4])(int, int) = {add, sub, mul, div};
    
    printf("%d\n", ops[0](10, 5)); // 15 (add)
    printf("%d\n", ops[1](10, 5)); // 5 (sub)
    printf("%d\n", ops[2](10, 5)); // 50 (mul)
    printf("%d\n", ops[3](10, 5)); // 2 (div)
    
    return 0;
}

================================================================================
6. УКАЗАТЕЛИ НА УКАЗАТЕЛИ (ДВОЙНЫЕ УКАЗАТЕЛИ)
================================================================================

6.1 СИНТАКСИС И ИСПОЛЬЗОВАНИЕ

Определение: Указатель на указатель - это переменная, которая хранит адрес другого указателя.

Синтаксис:
тип **ptr;

Описание:
- **ptr - это указатель на указатель
- Используется реже, чем обычные указатели
- Полезна для изменения самого указателя (не только значения, на которое он указывает)
- Используется в двумерных массивах и динамическом выделении структур

Пример:
int x = 10;
int *ptr = &x;        // указатель на x
int **pptr = &ptr;    // указатель на указатель ptr

printf("%d\n", x);       // 10
printf("%d\n", *ptr);    // 10 (разыменуем ptr)
printf("%d\n", **pptr);  // 10 (разыменуем pptr, потом ptr)

printf("%p\n", &x);      // адрес x
printf("%p\n", ptr);     // адрес x (тоже)
printf("%p\n", &ptr);    // адрес ptr
printf("%p\n", pptr);    // адрес ptr (тоже)

---

6.2 ИЗМЕНЕНИЕ УКАЗАТЕЛЯ ЧЕРЕЗ ДВОЙНОЙ УКАЗАТЕЛЬ

Описание:
- Можно изменить значение самого указателя через **ptr
- Полезно для функций, которые должны изменить указатель в вызывающей функции

Пример:
void allocate(int **ptr) {
    *ptr = malloc(sizeof(int));
    if (*ptr != NULL) {
        **ptr = 42;
    }
}

int main() {
    int *ptr = NULL;
    allocate(&ptr);  // передаём адрес указателя
    
    printf("%d\n", *ptr); // 42
    
    free(ptr);
    return 0;
}

---

6.3 ДВУМЕРНЫЕ ДИНАМИЧЕСКИЕ МАССИВЫ

Описание:
- Используются для создания двумерных массивов во время выполнения
- Требуют выделения памяти для каждой строки

Пример:
int rows = 3, cols = 4;

// Выделяем память для указателей на строки
int **matrix = malloc(rows * sizeof(int*));

// Выделяем память для каждой строки
for (int i = 0; i < rows; i++) {
    matrix[i] = malloc(cols * sizeof(int));
}

// Используем матрицу
for (int i = 0; i < rows; i++) {
    for (int j = 0; j < cols; j++) {
        matrix[i][j] = i * cols + j;
        printf("%d ", matrix[i][j]);
    }
    printf("\n");
}

// Освобождаем память (важно освобождать в правильном порядке)
for (int i = 0; i < rows; i++) {
    free(matrix[i]);
}
free(matrix);

================================================================================
7. СТРОКИ И УКАЗАТЕЛИ
================================================================================

7.1 СТРОКИ КАК МАССИВЫ СИМВОЛОВ

Определение: Строка в C - это массив символов, заканчивающийся нулевым символом '\0'.

Описание:
- Каждый символ занимает 1 байт
- Последний символ всегда '\0' (нулевой символ)
- Имя строки - это указатель на первый символ
- Размер строки = количество символов + 1 для '\0'

Примеры:
char str[10] = "Hello";
// В памяти: H e l l o \0 ? ? ? ?

printf("%s\n", str);      // Hello
printf("%c\n", str[0]);   // H
printf("%c\n", *str);     // H (тоже)

---

7.2 УКАЗАТЕЛИ НА СТРОКИ

Описание:
- Указатель на строку хранит адрес первого символа
- Можно использовать для передачи строк функциям
- Строковые литералы - это указатели на const char

Примеры:
char str[] = "Hello";
char *ptr = str;

printf("%s\n", ptr);      // Hello
printf("%c\n", *ptr);     // H

// Строковый литерал
char *literal = "World";
printf("%s\n", literal);  // World

---

7.3 ДИНАМИЧЕСКИЕ СТРОКИ

Описание:
- Можно выделить память для строки во время выполнения
- Размер может быть определен из входных данных

Примеры:
char *str = malloc(50 * sizeof(char)); // выделяем место для строки до 49 символов
if (str != NULL) {
    strcpy(str, "Hello");
    printf("%s\n", str);
    
    strcat(str, " World");
    printf("%s\n", str);  // Hello World
    
    free(str);
}

Получение размера строки:
char str[] = "Hello";
printf("Длина: %lu\n", strlen(str)); // 5 (без '\0')

---

7.4 МАССИВ УКАЗАТЕЛЕЙ НА СТРОКИ

Описание:
- Можно создать массив строк, используя массив указателей
- Каждый элемент - это указатель на строку

Примеры:
char *names[] = {"Alice", "Bob", "Charlie", "Diana"};

printf("%s\n", names[0]);  // Alice
printf("%s\n", names[1]);  // Bob
printf("%c\n", names[2][0]); // C (первый символ "Charlie")

for (int i = 0; i < 4; i++) {
    printf("%s\n", names[i]);
}

================================================================================
8. ЧАСТЫЕ ОШИБКИ И ОПАСНОСТИ
================================================================================

8.1 НЕИНИЦИАЛИЗИРОВАННЫЙ УКАЗАТЕЛЬ (ДИКИЙ УКАЗАТЕЛЬ)

Ошибка - Неинициализированный указатель:
int *ptr;  // не инициализирован!
*ptr = 10; // undefined behavior - крах программы

Правильно:
int *ptr = NULL;  // инициализируем NULL
int x = 10;
ptr = &x;  // теперь указывает на x
*ptr = 20; // безопасно

---

8.2 РАЗЫМЕНОВАНИЕ NULL УКАЗАТЕЛЯ

Ошибка:
int *ptr = NULL;
printf("%d\n", *ptr);  // segmentation fault - крах

Правильно:
int *ptr = NULL;
if (ptr != NULL) {
    printf("%d\n", *ptr);  // разыменуем только если не NULL
} else {
    printf("Указатель NULL\n");
}

---

8.3 УТЕЧКА ПАМЯТИ

Ошибка - Память выделена, но не освобождена:
void function() {
    int *ptr = malloc(sizeof(int));
    *ptr = 42;
}  // функция завершилась, но память не освобождена!

Правильно:
void function() {
    int *ptr = malloc(sizeof(int));
    *ptr = 42;
    free(ptr);  // освобождаем память
}

---

8.4 ДВОЙНОЕ ОСВОБОЖДЕНИЕ

Ошибка:
int *ptr = malloc(sizeof(int));
free(ptr);
free(ptr);  // undefined behavior - крах

Правильно:
int *ptr = malloc(sizeof(int));
free(ptr);
ptr = NULL;  // устанавливаем NULL после free()

// Позже проверяем:
if (ptr != NULL) {
    free(ptr);  // безопасно, так как ptr == NULL
}

---

8.5 ПОВИСШИЙ УКАЗАТЕЛЬ (DANGLING POINTER)

Ошибка:
int *ptr;
{
    int x = 10;
    ptr = &x;  // указатель на локальную переменную
}  // x вышла из области видимости
printf("%d\n", *ptr);  // undefined behavior - x больше не существует

Правильно:
int *ptr = malloc(sizeof(int));
*ptr = 10;
printf("%d\n", *ptr);  // безопасно
free(ptr);

---

8.6 ОШИБКА: ЗАБЫВАНИЕ ПРОВЕРКИ NULL ПОСЛЕ MALLOC

Ошибка:
int *ptr = malloc(sizeof(int));
*ptr = 42;  // может быть crash если malloc вернул NULL

Правильно:
int *ptr = malloc(sizeof(int));
if (ptr == NULL) {
    printf("Ошибка: не удалось выделить память\n");
    return;
}
*ptr = 42;
free(ptr);

---

8.7 ОШИБКА: НЕПРАВИЛЬНОЕ ИСПОЛЬЗОВАНИЕ SIZEOF

Ошибка:
int *ptr = malloc(10);  // выделяем только 10 байт
ptr[0] = 1;
ptr[1] = 2;
ptr[2] = 3;  // может быть за пределами памяти

Правильно:
int *ptr = malloc(10 * sizeof(int));  // выделяем место для 10 int
if (ptr != NULL) {
    for (int i = 0; i < 10; i++) {
        ptr[i] = i;
    }
    free(ptr);
}

================================================================================
9. ПРАКТИЧЕСКИЕ ПРИМЕРЫ
================================================================================

9.1 ПРИМЕР 1: БАЗОВОЕ ИСПОЛЬЗОВАНИЕ УКАЗАТЕЛЕЙ

#include <stdio.h>

int main() {
    int x = 10;
    int y = 20;
    
    int *ptr_x = &x;
    int *ptr_y = &y;
    
    printf("Значение x: %d\n", x);
    printf("Значение через указатель: %d\n", *ptr_x);
    
    printf("Адрес x: %p\n", &x);
    printf("Адрес через указатель: %p\n", ptr_x);
    
    *ptr_x = 30;  // изменяем x через указатель
    printf("Новое значение x: %d\n", x);
    
    return 0;
}

Вывод:
Значение x: 10
Значение через указатель: 10
Адрес x: 0x7fff5fbff8ac
Адрес через указатель: 0x7fff5fbff8ac
Новое значение x: 30

---

9.2 ПРИМЕР 2: ДИНАМИЧЕСКОЕ ВЫДЕЛЕНИЕ ПАМЯТИ

#include <stdio.h>
#include <stdlib.h>

int main() {
    int n = 5;
    
    // Выделяем память для массива из 5 элементов
    int *arr = malloc(n * sizeof(int));
    
    if (arr == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }
    
    // Инициализируем массив
    for (int i = 0; i < n; i++) {
        arr[i] = (i + 1) * 10;
    }
    
    // Выводим массив
    printf("Массив: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    
    // Освобождаем память
    free(arr);
    arr = NULL;
    
    return 0;
}

Вывод: Массив: 10 20 30 40 50

---

9.3 ПРИМЕР 3: УКАЗАТЕЛИ И СТРОКИ

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main() {
    char *str = malloc(50 * sizeof(char));
    
    if (str == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }
    
    strcpy(str, "Hello");
    printf("Строка: %s\n", str);
    printf("Длина: %lu\n", strlen(str));
    printf("Первый символ: %c\n", str[0]);
    
    strcat(str, " World");
    printf("Строка после strcat: %s\n", str);
    
    free(str);
    str = NULL;
    
    return 0;
}

Вывод:
Строка: Hello
Длина: 5
Первый символ: H
Строка после strcat: Hello World

---

9.4 ПРИМЕР 4: ОБМЕН ЗНАЧЕНИЙ ЧЕРЕЗ УКАЗАТЕЛИ

#include <stdio.h>

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 10, y = 20;
    
    printf("До: x = %d, y = %d\n", x, y);
    
    swap(&x, &y);
    
    printf("После: x = %d, y = %d\n", x, y);
    
    return 0;
}

Вывод:
До: x = 10, y = 20
После: x = 20, y = 10

---

9.5 ПРИМЕР 5: УКАЗАТЕЛИ НА СТРУКТУРЫ

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Student {
    int id;
    char name[50];
    float gpa;
};

int main() {
    struct Student *student = malloc(sizeof(struct Student));
    
    if (student == NULL) {
        printf("Ошибка выделения памяти\n");
        return 1;
    }
    
    student->id = 1;
    strcpy(student->name, "Alice");
    student->gpa = 3.8;
    
    printf("ID: %d\n", student->id);
    printf("Имя: %s\n", student->name);
    printf("GPA: %.1f\n", student->gpa);
    
    free(student);
    student = NULL;
    
    return 0;
}

Вывод:
ID: 1
Имя: Alice
GPA: 3.8

---

9.6 ПРИМЕР 6: АРИФМЕТИКА УКАЗАТЕЛЕЙ

#include <stdio.h>

int main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *ptr = arr;
    
    printf("arr[0] через указатель: %d\n", *ptr);
    printf("arr[2] через указатель: %d\n", *(ptr + 2));
    printf("arr[4] через указатель: %d\n", *(ptr + 4));
    
    ptr++;
    printf("После ptr++: %d\n", *ptr);  // теперь arr[1]
    
    ptr += 2;
    printf("После ptr += 2: %d\n", *ptr);  // теперь arr[3]
    
    return 0;
}

Вывод:
arr[0] через указатель: 10
arr[2] через указатель: 30
arr[4] через указатель: 50
После ptr++: 20
После ptr += 2: 40

---

9.7 ПРИМЕР 7: ДВОЙНОЙ УКАЗАТЕЛЬ

#include <stdio.h>

int main() {
    int x = 42;
    int *ptr = &x;
    int **pptr = &ptr;
    
    printf("x = %d\n", x);
    printf("*ptr = %d\n", *ptr);
    printf("**pptr = %d\n", **pptr);
    
    printf("\nАдреса:\n");
    printf("Адрес x: %p\n", &x);
    printf("ptr содержит: %p\n", ptr);
    printf("Адрес ptr: %p\n", &ptr);
    printf("pptr содержит: %p\n", pptr);
    
    **pptr = 100;
    printf("\nПосле **pptr = 100:\n");
    printf("x = %d\n", x);
    
    return 0;
}

Вывод:
x = 42
*ptr = 42
**pptr = 42

Адреса:
Адрес x: 0x7fff5fbff8ac
ptr содержит: 0x7fff5fbff8ac
Адрес ptr: 0x7fff5fbff8b0
pptr содержит: 0x7fff5fbff8b0

После **pptr = 100:
x = 100

---

9.8 ПРИМЕР 8: ДИНАМИЧЕСКИЙ ДВУМЕРНЫЙ МАССИВ

#include <stdio.h>
#include <stdlib.h>

int main() {
    int rows = 3, cols = 4;
    
    // Выделяем память для указателей на строки
    int **matrix = malloc(rows * sizeof(int*));
    
    // Выделяем память для каждой строки
    for (int i = 0; i < rows; i++) {
        matrix[i] = malloc(cols * sizeof(int));
    }
    
    // Инициализируем матрицу
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = i * cols + j + 1;
        }
    }
    
    // Выводим матрицу
    printf("Матрица:\n");
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%2d ", matrix[i][j]);
        }
        printf("\n");
    }
    
    // Освобождаем память
    for (int i = 0; i < rows; i++) {
        free(matrix[i]);
    }
    free(matrix);
    
    return 0;
}

Вывод:
Матрица:
 1  2  3  4
 5  6  7  8
 9 10 11 12

================================================================================
10. ТАБЛИЦА ОПЕРАЦИЙ С УКАЗАТЕЛЯМИ
================================================================================

Операция        | Описание                        | Пример              | Результат
---------------|---------------------------------|---------------------|----------
&переменная     | Адрес переменной                | &x                 | Адрес x в памяти
*указатель      | Разыменование (значение)       | *ptr               | Значение переменной
указатель++     | Переместить на следующий       | ptr++              | ptr указывает на следующий элемент
указатель--     | Переместить на предыдущий      | ptr--              | ptr указывает на предыдущий элемент
указатель + n   | Смещение на n элементов        | ptr + 3            | ptr указывает на 3-й элемент далее
ptr1 - ptr2     | Разница между указателями      | ptr1 - ptr2        | Количество элементов между ними
указатель->поле | Доступ к полю структуры        | ptr->name          | Значение поля name
*ptr.поле       | Альтернатива (менее ясно)      | (*ptr).name        | То же самое
malloc()        | Выделение памяти                | malloc(100)        | Указатель на выделенную память
free()          | Освобождение памяти             | free(ptr)          | Освобождает блок памяти
sizeof()        | Размер типа или переменной     | sizeof(int)        | 4 байта (обычно)

================================================================================
11. ЗАДАНИЯ ДЛЯ ПРОВЕРКИ ПОНИМАНИЯ
================================================================================

11.1 ВОПРОСЫ НА ПОНИМАНИЕ

Вопрос 1: Что хранит указатель?
Ответ: Адрес памяти переменной

Вопрос 2: Чему равен размер указателя на 64-битной системе?
Ответ: 8 байт

Вопрос 3: Какова разница между & и *?
Ответ: & получает адрес переменной, * получает значение по адресу (разыменование)

Вопрос 4: Что означает NULL указатель?
Ответ: Указатель, который не указывает ни на какой адрес (безопасное значение, обычно 0)

Вопрос 5: Что произойдёт, если разыменовать неинициализированный указатель?
Ответ: Undefined behavior - обычно крах программы (segmentation fault)

Вопрос 6: В чём разница между malloc() и calloc()?
Ответ: malloc() не инициализирует память, calloc() инициализирует нулями

Вопрос 7: Что такое "повисший указатель" (dangling pointer)?
Ответ: Указатель, который указывает на адрес, памяти, которая была освобождена или вышла из области видимости

Вопрос 8: Обязательно ли освобождать память, выделенную malloc()?
Ответ: Да, это вызывает утечку памяти, если не освободить

Вопрос 9: Как правильно увеличить размер динамического блока памяти?
Ответ: Использовать realloc()

Вопрос 10: Что означает arr[i] в C при использовании указателей?
Ответ: Это эквивалентно *(arr + i)

---

11.2 ПРАКТИЧЕСКИЕ ЗАДАЧИ

Задача 1: Напишите функцию, которая обменивает значения двух переменных используя указатели
Ключевые концепции: Передача параметров по ссылке, разыменование указателя

Задача 2: Создайте программу для выделения динамического массива и инициализации его значениями
Ключевые концепции: malloc(), итерация через указатели, free()

Задача 3: Напишите программу для работы со строками используя указатели
Ключевые концепции: Указатели на char, strlen(), strcpy(), strcat()

Задача 4: Создайте программу для работы со структурой используя динамическое выделение памяти
Ключевые концепции: malloc() для структуры, оператор ->, free()

Задача 5: Напишите функцию для нахождения минимума в массиве используя указатели вместо индексов
Ключевые концепции: Арифметика указателей, сравнение указателей

Задача 6: Создайте программу для создания двумерного динамического массива
Ключевые концепции: Двойные указатели, вложенные malloc(), освобождение памяти

Задача 7: Напишите программу, демонстрирующую разницу между массивом указателей и указателем на массив
Ключевые концепции: char *arr[] vs int (*arr)[], синтаксис объявления

================================================================================
12. РЕЗЮМЕ КЛЮЧЕВЫХ КОНЦЕПЦИЙ
================================================================================

1. Указатель - это переменная, которая хранит адрес памяти
2. Оператор & возвращает адрес переменной
3. Оператор * разыменовывает указатель (получает значение)
4. NULL - это безопасное значение для неинициализированного указателя
5. malloc() выделяет память на куче динамически
6. free() освобождает динамически выделенную память
7. Утечка памяти - это когда malloc() память не освобождается
8. Повисший указатель - это указатель на освобождённую или невалидную память
9. Массив - это указатель на первый элемент
10. Арифметика указателей смещает на элементы, не на байты
11. Указатель на структуру использует -> для доступа к полям
12. Двойной указатель (**) хранит адрес указателя
13. Всегда проверяйте NULL после malloc()
14. Используйте sizeof() при выделении памяти
15. Правильный порядок освобождения памяти критичен для двумерных массивов

================================================================================
Конец документа
================================================================================