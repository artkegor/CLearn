ПРЕПРОЦЕССОРЫ В ПРОГРАММИРОВАНИИ

================================================================================
1. ОСНОВНЫЕ ПОНЯТИЯ
================================================================================

1.1 ЧТО ТАКОЕ ПРЕПРОЦЕССОР

Определение: Препроцессор - это программа, которая обрабатывает исходный код C перед его компиляцией.

Ключевые характеристики:
- Обработка до компиляции: препроцессор работает перед компилятором
- Текстовые преобразования: производит текстовые замены и включения
- Директивы: обработка специальных команд, начинающихся с #
- Условная компиляция: позволяет включать/исключать код на основе условий
- Макросы: замена текста в коде
- Подключение файлов: включение других файлов в исходный код

Пример на C:
#include <stdio.h>
#define MAX 100
#define SQUARE(x) ((x) * (x))

int main() {
    printf("Максимум: %d\n", MAX);
    printf("Квадрат 5: %d\n", SQUARE(5));
    return 0;
}

---

1.2 КОГДА ПРЕПРОЦЕССОР РАБОТАЕТ

Этапы компиляции C:
1. Препроцессинг (Preprocessing): обработка директив #
2. Компиляция (Compilation): преобразование в ассемблер
3. Ассемблирование (Assembly): преобразование в машинный код
4. Компоновка (Linking): связывание объектных файлов

Препроцессор обрабатывает только текст до компиляции!

---

1.3 ДИРЕКТИВЫ ПРЕПРОЦЕССОРА

Все директивы препроцессора начинаются с символа #

Основные директивы:
- #include: включение содержимого другого файла
- #define: определение макроса или константы
- #undef: отмена определения макроса
- #ifdef: условная компиляция (если определено)
- #ifndef: условная компиляция (если не определено)
- #if: условная компиляция (if условие истинно)
- #else: альтернатива для условной компиляции
- #elif: else if для условной компиляции
- #endif: завершение условного блока
- #error: генерирование ошибки компиляции
- #pragma: специальная директива компилятора
- #line: изменение номера строки и имени файла

================================================================================
2. ДИРЕКТИВА #INCLUDE
================================================================================

2.1 СИНТАКСИС И ИСПОЛЬЗОВАНИЕ

Синтаксис:
#include <имя_файла>  // системные заголовки
#include "имя_файла"  // пользовательские файлы

Описание:
- Включает содержимое другого файла в исходный код
- < > для системных заголовков (в стандартных каталогах)
- " " для пользовательских файлов (в текущем каталоге)
- Препроцессор просто копирует содержимое файла в эту позицию

Примеры:
#include <stdio.h>      // системный заголовок
#include <stdlib.h>     // системный заголовок
#include <string.h>     // системный заголовок
#include <math.h>       // математические функции
#include "myheader.h"   // пользовательский заголовок
#include "config.h"     // конфигурационный файл

---

2.2 СИСТЕМНЫЕ ЗАГОЛОВКИ (СТАНДАРТНАЯ БИБЛИОТЕКА)

Часто используемые заголовки:

stdio.h - Ввод/вывод
- printf(), scanf(), fprintf(), fopen(), fclose(), и т.д.

stdlib.h - Стандартная библиотека
- malloc(), free(), calloc(), realloc()
- rand(), srand(), abs(), exit()

string.h - Работа со строками
- strlen(), strcpy(), strcat(), strcmp(), strchr()

math.h - Математические функции
- sin(), cos(), sqrt(), pow(), floor(), ceil()

ctype.h - Классификация символов
- isdigit(), isalpha(), isupper(), islower(), isspace()

time.h - Работа со временем
- time(), clock(), localtime(), strftime()

assert.h - Проверка утверждений
- assert() - макрос для проверки условий

limits.h - Пределы типов данных
- INT_MAX, INT_MIN, CHAR_MAX, и т.д.

float.h - Пределы типов с плавающей точкой
- FLT_MAX, DBL_MAX, и т.д.

---

2.3 ПОЛЬЗОВАТЕЛЬСКИЕ ЗАГОЛОВКИ

Структура пользовательского файла заголовка:

Файл: myheader.h
#ifndef MYHEADER_H
#define MYHEADER_H

// Объявления функций
int add(int a, int b);
int subtract(int a, int b);

#define PI 3.14159

#endif

Использование в основном файле:

Файл: main.c
#include "myheader.h"
#include <stdio.h>

int main() {
    int result = add(10, 5);
    printf("Результат: %d\n", result);
    printf("Pi: %.5f\n", PI);
    return 0;
}

---

2.4 GUARDS (ЗАЩИТА ОТ ДУБЛИРОВАНИЯ)

Проблема - Циклическое включение:

Файл: a.h
#include "b.h"
int a = 1;

Файл: b.h
#include "a.h"
int b = 2;

Файл: main.c
#include "a.h"  // включает b.h, который включает a.h... бесконечный цикл!

Решение - Include Guards:

Файл: a.h
#ifndef A_H
#define A_H

int a = 1;

#endif

Файл: b.h
#ifndef B_H
#define B_H

#include "a.h"

int b = 2;

#endif

Альтернативное решение - #pragma once:

Файл: myheader.h
#pragma once

int value = 42;

// Примечание: #pragma once не стандартен, но поддерживается большинством компиляторов

================================================================================
3. ДИРЕКТИВА #DEFINE
================================================================================

3.1 ОПРЕДЕЛЕНИЕ КОНСТАНТ

Синтаксис:
#define ИМЯ значение

Описание:
- Создаёт именованную константу (или макрос замещения)
- Препроцессор заменяет все вхождения ИМЯ на значение
- Нет проверки типов (текстовая замена!)
- Применяется ДО компиляции

Примеры:
#define MAX 100
#define PI 3.14159
#define BUFFER_SIZE 256
#define TRUE 1
#define FALSE 0
#define MIN(a, b) ((a) < (b) ? (a) : (b))

Использование:
int arr[MAX];  // препроцессор заменит MAX на 100 -> int arr[100];
float radius = 5.0;
float area = PI * radius * radius;  // PI -> 3.14159

---

3.2 МАКРОСЫ (ФУНКЦИОПОДОБНЫЕ МАКРОСЫ)

Синтаксис:
#define ИМЯ(параметры) замена

Описание:
- Макрос, который выглядит как функция
- Нет пробела между ИМЯ и скобкой
- Параметры заменяются как текст, а не вычисляются
- Расширяется инлайн (нет вызова функции)

Примеры:
#define SQUARE(x) ((x) * (x))
#define ADD(a, b) ((a) + (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define DOUBLE(x) ((x) * 2)
#define ABS(x) ((x) < 0 ? -(x) : (x))

Использование:
int result = SQUARE(5);  // препроцессор заменит на ((5) * (5)) = 25
int sum = ADD(10, 20);   // ((10) + (20)) = 30
int max_val = MAX(15, 10); // ((15) > (10) ? (15) : (10)) = 15

---

3.3 МНОГОСТРОЧНЫЕ МАКРОСЫ

Синтаксис:
#define ИМЯ \
    строка1 \
    строка2 \
    строка3

Описание:
- Использует обратный слэш (\) для продолжения на следующую строку
- Все строки объединяются в одну
- Последняя строка не должна заканчиваться слэшем

Пример:
#define PRINT_INFO(name, age) \
    printf("Имя: %s\n", name); \
    printf("Возраст: %d\n", age)

Использование:
PRINT_INFO("Alice", 25);
// препроцессор заменит на:
// printf("Имя: %s\n", "Alice");
// printf("Возраст: %d\n", 25);

---

3.4 ОПЕРАЦИИ НА МАКРОСАХ

Оператор # (Stringification) - преобразование в строку:

#define STR(x) #x

printf("%s\n", STR(hello));  // "hello"
printf("%s\n", STR(42));     // "42"

Оператор ## (Token Pasting) - соединение токенов:

#define CONCAT(a, b) a ## b

int CONCAT(var, 1) = 10;  // int var1 = 10;
int CONCAT(var, 2) = 20;  // int var2 = 20;

Пример сложного макроса:

#define DEBUG(x) printf(#x " = %d\n", x)

int value = 42;
DEBUG(value);  // printf("value" " = %d\n", 42); -> value = 42

---

3.5 ДИРЕКТИВА #UNDEF

Синтаксис:
#undef ИМЯ

Описание:
- Отменяет предыдущее определение макроса
- После #undef макрос больше не используется
- Можно переопределить после #undef

Пример:
#define MAX 100
int arr[MAX];  // int arr[100];

#undef MAX
#define MAX 200
int arr2[MAX];  // int arr2[200];

================================================================================
4. УСЛОВНАЯ КОМПИЛЯЦИЯ
================================================================================

4.1 ДИРЕКТИВА #IFDEF (IF DEFINED)

Синтаксис:
#ifdef ИМЯ
    // код, если ИМЯ определено
#endif

Описание:
- Проверяет, определено ли ИМЯ (макрос)
- Если определено, включает код
- Если не определено, исключает код

Примеры:
#define DEBUG

#ifdef DEBUG
    printf("Режим отладки включён\n");
#endif

#define VERSION 1

#ifdef VERSION
    printf("Версия: %d\n", VERSION);
#endif

Использование для конфигурации:

#define DEVELOPMENT

#ifdef DEVELOPMENT
    #define MAX_USERS 10
#else
    #define MAX_USERS 1000
#endif

---

4.2 ДИРЕКТИВА #IFNDEF (IF NOT DEFINED)

Синтаксис:
#ifndef ИМЯ
    // код, если ИМЯ НЕ определено
#endif

Описание:
- Проверяет, не определено ли ИМЯ
- Если не определено, включает код
- Если определено, исключает код

Примеры:
#ifndef DEBUG
    #define DEBUG
#endif

#ifndef MAX_SIZE
    #define MAX_SIZE 1024
#endif

Использование для защиты от дублирования (Include Guards):

Файл: header.h
#ifndef HEADER_H
#define HEADER_H

// содержимое заголовка

#endif

---

4.3 ДИРЕКТИВА #IF, #ELSE, #ELIF, #ENDIF

Синтаксис:
#if условие
    // код если условие истинно
#elif условие2
    // код если условие2 истинно
#else
    // код по умолчанию
#endif

Описание:
- Условия вычисляются препроцессором
- Можно использовать константные выражения
- #elif и #else опциональны

Примеры:
#define COMPILER 1

#if COMPILER == 1
    // используется первый компилятор
#elif COMPILER == 2
    // используется второй компилятор
#else
    // другой компилятор
#endif

Определение для разных платформ:

#if defined(__WIN32__)
    #define PLATFORM "Windows"
#elif defined(__APPLE__)
    #define PLATFORM "macOS"
#elif defined(__linux__)
    #define PLATFORM "Linux"
#else
    #define PLATFORM "Unknown"
#endif

---

4.4 ДИРЕКТИВА #ERROR И #WARNING

Синтаксис:
#error сообщение
#pragma message "предупреждение"

Описание:
- #error: прерывает компиляцию с сообщением об ошибке
- #pragma message: выводит предупреждение (специфично для компилятора)

Примеры:
#ifndef MAJOR_VERSION
#error "MAJOR_VERSION не определена"
#endif

#if __STDC_VERSION__ < 199901L
#error "Требуется C99 или выше"
#endif

#pragma message "Это сообщение об отладке"

---

4.5 ДИРЕКТИВА DEFINED()

Синтаксис:
#if defined(ИМЯ)
#if !defined(ИМЯ)

Описание:
- Проверяет, определено ли ИМЯ в условии #if
- Эквивалентна #ifdef/#ifndef но более явна

Примеры:
#if defined(DEBUG) && defined(VERBOSE)
    printf("Подробный режим отладки\n");
#endif

#if !defined(MAX)
    #define MAX 100
#endif

================================================================================
5. СПЕЦИАЛЬНЫЕ МАКРОСЫ ПРЕПРОЦЕССОРА
================================================================================

5.1 ВСТРОЕННЫЕ МАКРОСЫ

Препроцессор предоставляет встроенные макросы:

__FILE__ - Имя текущего файла исходного кода
__LINE__ - Номер текущей строки
__DATE__ - Дата компиляции (строка)
__TIME__ - Время компиляции (строка)
__STDC__ - Стандарт ANSI C (если компилятор совместим)
__STDC_VERSION__ - Версия стандарта C (C99=199901L, C11=201112L)

Примеры:
printf("Файл: %s\n", __FILE__);      // main.c
printf("Строка: %d\n", __LINE__);    // 42
printf("Дата: %s\n", __DATE__);      // Dec 17 2025
printf("Время: %s\n", __TIME__);     // 19:35:00

Использование для отладки:

#define DEBUG_PRINT printf("%s:%d: ", __FILE__, __LINE__); printf

DEBUG_PRINT("Значение x = %d\n", x);
// Выведет: main.c:42: Значение x = 10

---

5.2 МАКРОСЫ ДЛЯ ВЫДЕЛЕНИЯ ПАМЯТИ

Часто используются для упрощения работы:

#define MALLOC(type) ((type*) malloc(sizeof(type)))
#define CALLOC(n, type) ((type*) calloc(n, sizeof(type)))
#define FREE(ptr) { free(ptr); ptr = NULL; }

Использование:
int *ptr = MALLOC(int);
*ptr = 42;
FREE(ptr);

int *arr = CALLOC(10, int);
// работа с массивом
FREE(arr);

---

5.3 МАКРОСЫ ДЛЯ ПРОВЕРКИ ТИПОВ

Проверка на нулевое значение:

#define NULL_CHECK(ptr) if ((ptr) == NULL) return NULL

Проверка на диапазон:

#define IN_RANGE(x, min, max) ((x) >= (min) && (x) <= (max))

Использование:
int *ptr = malloc(sizeof(int));
NULL_CHECK(ptr);

int value = 50;
if (IN_RANGE(value, 0, 100)) {
    printf("Значение в диапазоне\n");
}

================================================================================
6. ПРАКТИЧЕСКИЕ ПРИМЕРЫ
================================================================================

6.1 ПРИМЕР 1: БАЗОВЫЕ МАКРОСЫ И КОНСТАНТЫ

#include <stdio.h>

#define PI 3.14159
#define SQUARE(x) ((x) * (x))
#define CUBE(x) ((x) * (x) * (x))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

int main() {
    float radius = 5.0;
    printf("Площадь круга: %.2f\n", PI * SQUARE(radius));
    
    int x = 3;
    printf("Куб от 3: %d\n", CUBE(x));
    
    int a = 10, b = 20;
    printf("Макс: %d, Мин: %d\n", MAX(a, b), MIN(a, b));
    
    return 0;
}

Вывод:
Площадь круга: 78.50
Куб от 3: 27
Макс: 20, Мин: 10

---

6.2 ПРИМЕР 2: УСЛОВНАЯ КОМПИЛЯЦИЯ ДЛЯ ОТЛАДКИ

#include <stdio.h>

#define DEBUG 1

#ifdef DEBUG
    #define LOG(msg) printf("[DEBUG] %s\n", msg)
#else
    #define LOG(msg)  // пустой макрос
#endif

int main() {
    LOG("Программа начала выполнение");
    
    int x = 10;
    LOG("Переменная x инициализирована");
    
    printf("x = %d\n", x);
    
    LOG("Программа завершена");
    
    return 0;
}

Вывод (с DEBUG=1):
[DEBUG] Программа начала выполнение
[DEBUG] Переменная x инициализирована
x = 10
[DEBUG] Программа завершена

Вывод (без DEBUG):
x = 10

---

6.3 ПРИМЕР 3: МАКРОСЫ ДЛЯ РАЗНЫХ КОНФИГУРАЦИЙ

#include <stdio.h>

#define PRODUCTION 0

#if PRODUCTION
    #define MAX_USERS 10000
    #define TIMEOUT 300
    #define LOG(msg)
#else
    #define MAX_USERS 100
    #define TIMEOUT 30
    #define LOG(msg) printf("[LOG] %s\n", msg)
#endif

int main() {
    LOG("Запуск в режиме разработки");
    
    printf("Макс. пользователей: %d\n", MAX_USERS);
    printf("Timeout: %d сек\n", TIMEOUT);
    
    return 0;
}

Вывод (при PRODUCTION=0):
[LOG] Запуск в режиме разработки
Макс. пользователей: 100
Timeout: 30 сек

---

6.4 ПРИМЕР 4: ЗАЩИТА ЗАГОЛОВКА ОТ ДУБЛИРОВАНИЯ

Файл: config.h
#ifndef CONFIG_H
#define CONFIG_H

#define APP_NAME "MyApp"
#define APP_VERSION "1.0.0"
#define MAX_BUFFER 256

#endif

Файл: utils.h
#ifndef UTILS_H
#define UTILS_H

#include "config.h"

void print_app_info();

#endif

Файл: main.c
#include <stdio.h>
#include "config.h"
#include "utils.h"
#include "config.h"  // не будет включён дважды

int main() {
    printf("Приложение: %s\n", APP_NAME);
    printf("Версия: %s\n", APP_VERSION);
    printf("Максимальный буфер: %d\n", MAX_BUFFER);
    
    return 0;
}

Вывод:
Приложение: MyApp
Версия: 1.0.0
Максимальный буфер: 256

---

6.5 ПРИМЕР 5: МАКРОСЫ ДЛЯ ПРОВЕРОК

#include <stdio.h>
#include <stdlib.h>

#define ASSERT(condition) \
    if (!(condition)) { \
        printf("Ошибка: условие не выполнено\n"); \
        exit(1); \
    }

#define ASSERT_MSG(condition, msg) \
    if (!(condition)) { \
        printf("Ошибка: %s\n", msg); \
        exit(1); \
    }

int main() {
    int x = 10;
    
    ASSERT(x > 0);
    printf("x больше нуля\n");
    
    ASSERT_MSG(x == 10, "x должна быть равна 10");
    printf("x равна 10\n");
    
    // Это вызовет ошибку:
    // ASSERT_MSG(x == 20, "x должна быть равна 20");
    
    return 0;
}

Вывод:
x больше нуля
x равна 10

---

6.6 ПРИМЕР 6: ДИНАМИЧЕСКИЕ МАКРОСЫ С STRINGIFICATION

#include <stdio.h>

#define VAR_NAME(x) #x
#define VALUE_WITH_NAME(x) #x " = " 

#define PRINT_VAR(x) printf(#x " = %d\n", x)
#define PRINT_FLOAT(x) printf(#x " = %.2f\n", x)

int main() {
    int age = 25;
    float height = 1.75;
    
    PRINT_VAR(age);
    PRINT_FLOAT(height);
    
    return 0;
}

Вывод:
age = 25
height = 1.75

---

6.7 ПРИМЕР 7: УСЛОВНАЯ КОМПИЛЯЦИЯ ДЛЯ ПЛАТФОРМ

#include <stdio.h>

#ifdef __WIN32__
    #define PLATFORM "Windows"
    #define LINE_ENDING "\r\n"
#elif defined(__APPLE__)
    #define PLATFORM "macOS"
    #define LINE_ENDING "\n"
#elif defined(__linux__)
    #define PLATFORM "Linux"
    #define LINE_ENDING "\n"
#else
    #define PLATFORM "Unknown"
    #define LINE_ENDING "\n"
#endif

int main() {
    printf("Платформа: %s%s", PLATFORM, LINE_ENDING);
    printf("Компилятор: %s%s", __STDC__ ? "ANSI C" : "Non-ANSI", LINE_ENDING);
    
    return 0;
}

Вывод (на Linux):
Платформа: Linux
Компилятор: ANSI C

---

6.8 ПРИМЕР 8: МАКРОСЫ ДЛЯ ВЫДЕЛЕНИЯ ПАМЯТИ

#include <stdio.h>
#include <stdlib.h>

#define ALLOC(type) ((type*) malloc(sizeof(type)))
#define ALLOC_ARRAY(type, n) ((type*) malloc((n) * sizeof(type)))
#define FREE(ptr) { if ((ptr) != NULL) { free((ptr)); (ptr) = NULL; } }

int main() {
    int *single = ALLOC(int);
    if (single != NULL) {
        *single = 42;
        printf("single = %d\n", *single);
        FREE(single);
    }
    
    int *array = ALLOC_ARRAY(int, 5);
    if (array != NULL) {
        for (int i = 0; i < 5; i++) {
            array[i] = i * 10;
            printf("array[%d] = %d\n", i, array[i]);
        }
        FREE(array);
    }
    
    printf("Всё освобождено, указатели = NULL\n");
    
    return 0;
}

Вывод:
single = 42
array[0] = 0
array[1] = 10
array[2] = 20
array[3] = 30
array[4] = 40
Всё освобождено, указатели = NULL

================================================================================
7. ТАБЛИЦА ДИРЕКТИВ ПРЕПРОЦЕССОРА
================================================================================

Директива       | Синтаксис                  | Описание
---------------|-----------------------------|--------------------------------------------------
#include       | #include <файл>            | Включение системного файла
#include       | #include "файл"            | Включение пользовательского файла
#define        | #define ИМЯ значение       | Определение макроса константы
#define        | #define ИМЯ(x) (x)         | Определение функциоподобного макроса
#undef         | #undef ИМЯ                 | Отмена определения макроса
#ifdef         | #ifdef ИМЯ                 | Проверка: определено ли
#ifndef        | #ifndef ИМЯ                | Проверка: не определено ли
#if            | #if условие                | Условная компиляция (if)
#elif          | #elif условие              | Условная компиляция (else if)
#else          | #else                      | Условная компиляция (else)
#endif         | #endif                     | Завершение условного блока
#error         | #error сообщение           | Генерирование ошибки компиляции
#pragma        | #pragma директива          | Специальная директива компилятора
#line          | #line число "файл"         | Изменение номера строки

================================================================================
8. ЧАСТЫЕ ОШИБКИ И ОПАСНОСТИ
================================================================================

8.1 ОШИБКА: МАКРОС БЕЗ СКОБОК

Ошибка:
#define DOUBLE(x) x * 2
int result = DOUBLE(5 + 3);  // 5 + 3 * 2 = 11 (неправильно!)

Правильно:
#define DOUBLE(x) ((x) * 2)
int result = DOUBLE(5 + 3);  // ((5 + 3) * 2) = 16 (правильно)

---

8.2 ОШИБКА: ПОБОЧНЫЕ ЭФФЕКТЫ В МАКРОСАХ

Ошибка:
#define SQUARE(x) ((x) * (x))
int a = 5;
int result = SQUARE(a++);  // ((a++) * (a++)) = ?
// a++ вычисляется дважды!

Правильно:
int a = 5;
int result = (a) * (a);
a++;

Лучше использовать функцию:
int square(int x) {
    return x * x;
}

---

8.3 ОШИБКА: ЗАБЫВАНИЕ ПРОБЕЛА ПОСЛЕ #DEFINE

Правильно:
#define MAX 100
#define ADD(a, b) ((a) + (b))

Обработка #define ADD (конец):
Это определяет макрос с пробелом в имени, что неправильно!

---

8.4 ОШИБКА: ПРОБЕЛ ПЕРЕД ОТКРЫВАЮЩЕЙ СКОБКОЙ

Правильно:
#define MAX(a, b) ((a) > (b) ? (a) : (b))

Неправильно:
#define MAX (a, b) ((a) > (b) ? (a) : (b))
// Это создаёт макрос MAX, который заменяется на "(a, b) ((a) > (b) ? (a) : (b))"

---

8.5 ОШИБКА: ЦИКЛИЧЕСКИЕ ВКЛЮЧЕНИЯ

Ошибка:

Файл: a.h
#include "b.h"
int a;

Файл: b.h
#include "a.h"
int b;

Файл: main.c
#include "a.h"  // a.h включает b.h, b.h включает a.h... бесконечный цикл!

Решение - Include Guards:

Файл: a.h
#ifndef A_H
#define A_H
#include "b.h"
int a;
#endif

Файл: b.h
#ifndef B_H
#define B_H
#include "a.h"
int b;
#endif

---

8.6 ОШИБКА: ТИПЫ НЕ ПРОВЕРЯЮТСЯ В МАКРОСАХ

Ошибка:
#define ADD(a, b) ((a) + (b))

int x = ADD(10, 20);
char* str = ADD("Hello", " World");  // Компилятор позволит, но может быть ошибка

Правильнее использовать функции:
int add(int a, int b) { return a + b; }

---

8.7 ОШИБКА: МАКРОС МОЖЕТ ИЗМЕНИТЬСЯ СЛУЧАЙНО

Ошибка:
#define MAX 100

// где-то позже в коде:
int MAX = 50;  // это просто переменная, но может привести к путанице

#undef MAX
#define MAX 200  // переопределили

Правильнее использовать const для констант:
const int MAX = 100;

---

8.8 ОШИБКА: НЕТИПИЗИРОВАННЫЕ ПАРАМЕТРЫ

Ошибка:
#define MAX(a, b) ((a) > (b) ? (a) : (b))
int x = MAX(10, 20.5);  // смешивание типов, нет проверки

Правильнее использовать функции с перегрузкой или использовать _Generic в C11

================================================================================
9. ЛУЧШИЕ ПРАКТИКИ
================================================================================

9.1 ИСПОЛЬЗОВАНИЕ МАКРОСОВ

- Используйте DEFINE для констант, когда это имеет смысл
- Используйте const для типизированных констант (предпочтительнее)
- Заключайте параметры в скобки: #define DOUBLE(x) ((x) * 2)
- Избегайте сложных макросов, используйте функции вместо них
- Документируйте сложные макросы с комментариями

---

9.2 УСЛОВНАЯ КОМПИЛЯЦИЯ

- Используйте для конфигурации и отладки
- Используйте Include Guards или #pragma once в заголовках
- Тестируйте все ветви условной компиляции
- Избегайте глубокой вложенности условных директив
- Используйте #define для конфигурационных параметров

---

9.3 СТРУКТУРА ПРОЕКТА

- Создавайте файлы конфигурации (config.h)
- Используйте Include Guards во всех заголовках
- Разделяйте декларации и определения
- Группируйте связанные макросы
- Используйте префиксы для макросов разных модулей

---

9.4 ОТЛАДКА

- Используйте условные макросы для отладочного вывода
- Используйте __FILE__ и __LINE__ для идентификации места ошибки
- Создавайте макросы для проверок и утверждений
- Отключайте отладочный вывод в продакшене

---

9.5 ТИПИЗАЦИЯ И БЕЗОПАСНОСТЬ

- Предпочитайте const для типизированных констант
- Используйте функции вместо сложных макросов
- Всегда заключайте параметры в скобки
- Проверяйте типы в функциях, а не в макросах
- Документируйте ограничения макросов

================================================================================
10. ЗАДАНИЯ ДЛЯ ПРОВЕРКИ ПОНИМАНИЯ
================================================================================

10.1 ВОПРОСЫ НА ПОНИМАНИЕ

Вопрос 1: Когда работает препроцессор - до или после компиляции?
Ответ: ДО компиляции, это первый этап обработки кода

Вопрос 2: Какая разница между #include <stdio.h> и #include "myfile.h"?
Ответ: < > для системных файлов в стандартных каталогах, " " для пользовательских в текущем каталоге

Вопрос 3: Зачем нужны Include Guards?
Ответ: Для предотвращения дублирования содержимого файла при его включении несколько раз

Вопрос 4: Какой результат #define MAX 100?
Ответ: Препроцессор заменит все вхождения MAX на 100 в исходном коде

Вопрос 5: В чём опасность макроса #define SQUARE(x) x * x?
Ответ: При использовании SQUARE(5 + 3) получится 5 + 3 * 3 = 14, а не 64

Вопрос 6: Что означает # в контексте макроса?
Ответ: Оператор stringification - преобразование параметра в строку

Вопрос 7: Что означает ## в контексте макроса?
Ответ: Token pasting - соединение токенов в один

Вопрос 8: Какая разница между #ifdef и #if defined()?
Ответ: Функционально одинаковы, но #if defined() более явен в условиях

Вопрос 9: Что произойдёт, если не заканчивать многострочный макрос обратным слэшем?
Ответ: Макрос будет незавершённым на одной строке и может привести к ошибкам компиляции

Вопрос 10: Какие встроенные макросы предоставляет препроцессор?
Ответ: __FILE__, __LINE__, __DATE__, __TIME__, __STDC__, __STDC_VERSION__

---

10.2 ПРАКТИЧЕСКИЕ ЗАДАЧИ

Задача 1: Напишите макрос для нахождения минимума двух чисел
Ключевые концепции: Функциоподобный макрос, скобки вокруг параметров

Задача 2: Создайте заголовок с Include Guards и несколькими макросами
Ключевые концепции: #ifndef, #define, #endif, Include Guards

Задача 3: Напишите систему отладки с условным выводом (включаемым/отключаемым)
Ключевые концепции: #ifdef, условные макросы, __FILE__, __LINE__

Задача 4: Создайте макрос для безопасного выделения памяти
Ключевые концепции: MALLOC, CALLOC, проверка NULL

Задача 5: Напишите макрос с использованием stringification для печати переменных
Ключевые концепции: Оператор #, форматированный вывод

Задача 6: Создайте конфигурационный файл для разных платформ
Ключевые концепции: Условная компиляция, __WIN32__, __linux__, __APPLE__

Задача 7: Напишите макрос для создания таблицы значений
Ключевые концепции: Token pasting ##, многострочные макросы

================================================================================
11. РЕЗЮМЕ КЛЮЧЕВЫХ КОНЦЕПЦИЙ
================================================================================

1. Препроцессор работает перед компиляцией, обрабатывая директивы
2. Все директивы препроцессора начинаются с символа #
3. #include включает содержимое другого файла
4. #define создаёт макросы (текстовые замены)
5. Функциоподобные макросы выглядят как функции но расширяются инлайн
6. Include Guards предотвращают дублирование содержимого файлов
7. Условная компиляция позволяет включать/исключать код
8. #ifdef/#ifndef проверяет, определено ли имя
9. #if/#elif/#else проверяют условия
10. Оператор # преобразует параметр в строку (stringification)
11. Оператор ## соединяет токены (token pasting)
12. Встроенные макросы: __FILE__, __LINE__, __DATE__, __TIME__
13. Всегда заключайте параметры в скобки в макросах
14. Макросы не имеют типизации (текстовые замены)
15. Используйте const вместо #define для типизированных констант

================================================================================
Конец документа
================================================================================