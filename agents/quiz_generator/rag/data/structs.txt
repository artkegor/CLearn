# СТРУКТУРЫ И ТИПЫ ДАННЫХ В ЯЗЫКЕ C - ПОЛНОЕ РУКОВОДСТВО

## 1. ОСНОВЫ СТРУКТУР

### Что такое структура
Структура (struct) в C — это составной тип данных, который позволяет объединить несколько переменных разных типов под одним именем. Структуры используются для представления сложных объектов и организации данных.

### Объявление структур
```c
#include <stdio.h>

// Способ 1: объявление структуры
struct Point {
    int x;      // член структуры
    int y;      // член структуры
};

// Способ 2: typedef для удобства
typedef struct {
    float width;
    float height;
} Rectangle;

// Способ 3: объявление с названием структуры и typedef одновременно
typedef struct Circle {
    float radius;
    char color[50];
} Circle;

int main() {
    // Создание переменной структуры (на стеке)
    struct Point p1;
    p1.x = 10;
    p1.y = 20;
    printf("Point: (%d, %d)\n", p1.x, p1.y);

    // Создание переменной typedef структуры (проще)
    Rectangle rect1;
    rect1.width = 5.0;
    rect1.height = 10.0;

    return 0;
}
```

### Инициализация структур
```c
#include <stdio.h>

struct Student {
    char name[50];
    int age;
    float gpa;
};

int main() {
    // Способ 1: объявление и инициализация поочередно
    struct Student s1;
    s1.age = 20;
    s1.gpa = 3.5;

    // Способ 2: инициализация при объявлении (в порядке объявления)
    struct Student s2 = {"Alice", 21, 3.8};

    // Способ 3: именованная инициализация (C99+)
    struct Student s3 = {
        .name = "Bob",
        .age = 22,
        .gpa = 3.6
    };

    // Способ 4: частичная инициализация (остальное = 0)
    struct Student s4 = {"Charlie"};  // age = 0, gpa = 0.0

    printf("Student: %s, Age: %d, GPA: %.1f\n", s2.name, s2.age, s2.gpa);

    return 0;
}
```

### Размер структуры
```c
#include <stdio.h>

struct Example {
    char c;        // 1 байт
    int i;         // 4 байта
    double d;      // 8 байт
};

int main() {
    printf("Size of struct Example: %zu bytes\n", sizeof(struct Example));
    // Может быть НЕ 13 (1+4+8) из-за выравнивания (padding)!
    // Обычно 16 или 24 байта

    printf("Offset of c: %zu\n", offsetof(struct Example, c));
    printf("Offset of i: %zu\n", offsetof(struct Example, i));
    printf("Offset of d: %zu\n", offsetof(struct Example, d));

    return 0;
}
```

### Вложенные структуры
```c
#include <stdio.h>

struct Address {
    char city[50];
    int zipcode;
};

struct Person {
    char name[50];
    int age;
    struct Address address;  // Вложенная структура
};

int main() {
    struct Person p1;
    p1.age = 30;
    p1.address.zipcode = 12345;
    strcpy(p1.address.city, "Moscow");

    printf("Person: %s, City: %s\n", p1.name, p1.address.city);

    return 0;
}
```

## 2. УКАЗАТЕЛИ НА СТРУКТУРЫ

### Создание указателя на структуру
```c
#include <stdio.h>
#include <stdlib.h>

struct Point {
    int x;
    int y;
};

int main() {
    // На стеке
    struct Point p1 = {10, 20};
    struct Point *ptr1 = &p1;  // Указатель на структуру на стеке

    // На куче
    struct Point *ptr2 = (struct Point *)malloc(sizeof(struct Point));
    if (ptr2 != NULL) {
        ptr2->x = 30;  // Оператор -> для доступа через указатель
        ptr2->y = 40;

        printf("Point: (%d, %d)\n", ptr2->x, ptr2->y);

        free(ptr2);  // ОБЯЗАТЕЛЬНО освобождаем
    }

    return 0;
}
```

### Оператор -> для доступа к членам
```c
#include <stdio.h>

struct Student {
    char name[50];
    int age;
};

int main() {
    struct Student s = {"Alice", 20};
    struct Student *ptr = &s;

    // Два способа доступа:

    // 1. Через оператор ->
    printf("Name: %s, Age: %d\n", ptr->name, ptr->age);

    // 2. Через разыменование и оператор .
    printf("Name: %s, Age: %d\n", (*ptr).name, (*ptr).age);

    // Они эквивалентны!

    return 0;
}
```

### Динамическое выделение структур
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[50];
    float salary;
    int id;
} Employee;

int main() {
    // Выделяем память для одной структуры
    Employee *emp1 = (Employee *)malloc(sizeof(Employee));
    if (emp1 == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    strcpy(emp1->name, "John Doe");
    emp1->salary = 50000.0;
    emp1->id = 101;

    printf("Employee: %s, Salary: %.2f\n", emp1->name, emp1->salary);

    free(emp1);

    return 0;
}
```

## 3. МАССИВЫ СТРУКТУР

### Одномерный массив структур
```c
#include <stdio.h>
#include <string.h>

struct Book {
    char title[100];
    char author[50];
    int year;
};

int main() {
    // Выделяем массив структур
    int n = 3;
    struct Book books[3] = {
        {"The C Programming Language", "Kernighan & Ritchie", 1988},
        {"C: A Reference Manual", "Harbison & Steele", 2002},
        {"Expert C Programming", "Peter van der Linden", 1994}
    };

    // Доступ к элементам
    for (int i = 0; i < n; i++) {
        printf("Book %d: %s by %s (%d)\n",
               i + 1, books[i].title, books[i].author, books[i].year);
    }

    return 0;
}
```

### Динамический массив структур
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int id;
    char name[50];
    float grade;
} Student;

int main() {
    int n;
    printf("Enter number of students: ");
    scanf("%d", &n);

    // Выделяем динамический массив структур
    Student *students = (Student *)malloc(n * sizeof(Student));
    if (students == NULL) {
        printf("Memory allocation failed!\n");
        return 1;
    }

    // Заполняем данные
    for (int i = 0; i < n; i++) {
        students[i].id = i + 1;
        printf("Enter name for student %d: ", i + 1);
        scanf("%49s", students[i].name);
        printf("Enter grade: ");
        scanf("%f", &students[i].grade);
    }

    // Выводим данные
    printf("\n--- Student List ---\n");
    for (int i = 0; i < n; i++) {
        printf("ID: %d, Name: %s, Grade: %.1f\n",
               students[i].id, students[i].name, students[i].grade);
    }

    free(students);
    return 0;
}
```

### Массив указателей на структуры
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[50];
    int age;
} Person;

int main() {
    int n = 3;

    // Массив указателей на структуры
    Person **people = (Person **)malloc(n * sizeof(Person *));

    // Для каждого указателя выделяем память на структуру
    for (int i = 0; i < n; i++) {
        people[i] = (Person *)malloc(sizeof(Person));
        if (people[i] == NULL) return 1;
    }

    // Заполняем данные
    strcpy(people[0]->name, "Alice");
    people[0]->age = 25;

    strcpy(people[1]->name, "Bob");
    people[1]->age = 30;

    strcpy(people[2]->name, "Charlie");
    people[2]->age = 28;

    // Выводим
    for (int i = 0; i < n; i++) {
        printf("Person: %s, Age: %d\n", people[i]->name, people[i]->age);
    }

    // Освобождаем в обратном порядке
    for (int i = 0; i < n; i++) {
        free(people[i]);
    }
    free(people);

    return 0;
}
```

## 4. ФУНКЦИИ И СТРУКТУРЫ

### Передача структур в функции
```c
#include <stdio.h>

struct Rectangle {
    float width;
    float height;
};

// Передача по значению (копируется вся структура)
float getRectangleArea(struct Rectangle rect) {
    return rect.width * rect.height;
}

// ✅ ЛУЧШЕ: передача указателя (копируется только адрес)
void printRectangle(const struct Rectangle *rect) {
    printf("Width: %.2f, Height: %.2f\n", rect->width, rect->height);
}

// Изменение структуры через указатель
void setRectangleDimensions(struct Rectangle *rect, float w, float h) {
    rect->width = w;
    rect->height = h;
}

int main() {
    struct Rectangle r1 = {5.0, 10.0};

    float area = getRectangleArea(r1);
    printf("Area: %.2f\n", area);

    printRectangle(&r1);

    setRectangleDimensions(&r1, 7.0, 8.0);
    printRectangle(&r1);

    return 0;
}
```

### Возвращение структур из функций
```c
#include <stdio.h>

struct Point {
    int x;
    int y;
};

// Возвращение структуры по значению
struct Point createPoint(int x, int y) {
    struct Point p;
    p.x = x;
    p.y = y;
    return p;
}

// ✅ ЛУЧШЕ: возвращение указателя (если структура динамическая)
struct Point *createPointDynamic(int x, int y) {
    struct Point *p = (struct Point *)malloc(sizeof(struct Point));
    if (p != NULL) {
        p->x = x;
        p->y = y;
    }
    return p;
}

int main() {
    struct Point p1 = createPoint(10, 20);
    printf("Point: (%d, %d)\n", p1.x, p1.y);

    struct Point *p2 = createPointDynamic(30, 40);
    if (p2 != NULL) {
        printf("Point: (%d, %d)\n", p2->x, p2->y);
        free(p2);
    }

    return 0;
}
```

### Функции для работы с массивами структур
```c
#include <stdio.h>
#include <string.h>

typedef struct {
    int id;
    char name[50];
    int score;
} Player;

// Поиск игрока по ID
Player *findPlayerById(Player *players, int size, int id) {
    for (int i = 0; i < size; i++) {
        if (players[i].id == id) {
            return &players[i];
        }
    }
    return NULL;
}

// Сортировка по score (по убыванию)
void sortPlayersByScore(Player *players, int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = i + 1; j < size; j++) {
            if (players[i].score < players[j].score) {
                // Обмен структур
                Player temp = players[i];
                players[i] = players[j];
                players[j] = temp;
            }
        }
    }
}

int main() {
    Player players[] = {
        {1, "Alice", 100},
        {2, "Bob", 85},
        {3, "Charlie", 95}
    };
    int n = 3;

    sortPlayersByScore(players, n);

    printf("Top Players:\n");
    for (int i = 0; i < n; i++) {
        printf("%d. %s: %d points\n", i + 1, players[i].name, players[i].score);
    }

    Player *found = findPlayerById(players, n, 2);
    if (found != NULL) {
        printf("Found: %s with %d points\n", found->name, found->score);
    }

    return 0;
}
```

## 5. ОБЪЕДИНЕНИЯ (UNION)

### Что такое объединение
Объединение — это тип данных, похожий на структуру, но все члены СОВМЕСТНО ИСПОЛЬЗУЮТ один и тот же блок памяти. Размер объединения равен размеру его наибольшего члена.

```c
#include <stdio.h>

// Структура: каждый член занимает свою память
struct Data1 {
    int i;      // 4 байта
    float f;    // 4 байта
    char c;     // 1 байт
};
// Размер: 4 + 4 + 1 = 9 байт (может быть 12 с выравниванием)

// Объединение: все члены используют одну память
union Data2 {
    int i;      // 4 байта
    float f;    // 4 байта
    char c;     // 1 байт
};
// Размер: MAX(4, 4, 1) = 4 байта

int main() {
    printf("Size of struct Data1: %zu bytes\n", sizeof(struct Data1));  // 12 или 13
    printf("Size of union Data2: %zu bytes\n", sizeof(union Data2));    // 4

    return 0;
}
```

### Использование объединений
```c
#include <stdio.h>

union Value {
    int intVal;
    float floatVal;
    char charVal;
};

int main() {
    union Value v;

    // Устанавливаем значение
    v.intVal = 42;
    printf("intVal: %d\n", v.intVal);      // 42

    // Переписываем другим значением (перезаписывает память!)
    v.floatVal = 3.14f;
    printf("floatVal: %.2f\n", v.floatVal);  // 3.14
    printf("intVal: %d\n", v.intVal);        // Мусор! (изменилось)

    // Только последнее установленное значение корректно

    return 0;
}
```

### Объединение в структуре (вариант типа)
```c
#include <stdio.h>

// Тип данных (может быть числом, строкой или булево)
typedef struct {
    int type;  // 1 = int, 2 = float, 3 = string
    union {
        int intValue;
        float floatValue;
        char stringValue[50];
    } value;
} Variable;

int main() {
    Variable v1;
    v1.type = 1;
    v1.value.intValue = 42;
    printf("Variable 1: %d\n", v1.value.intValue);

    Variable v2;
    v2.type = 2;
    v2.value.floatValue = 3.14f;
    printf("Variable 2: %.2f\n", v2.value.floatValue);

    return 0;
}
```

## 6. ПЕРЕЧИСЛЕНИЯ (ENUM)

### Основы перечисления
```c
#include <stdio.h>

// Перечисление: набор именованных констант
enum Color {
    RED = 0,
    GREEN = 1,
    BLUE = 2
};

enum Status {
    ACTIVE,     // 0
    INACTIVE,   // 1
    SUSPENDED   // 2
};

// С typedef для удобства
typedef enum {
    JANUARY = 1,
    FEBRUARY,   // 2
    MARCH,      // 3
    // ... и так далее
    DECEMBER = 12
} Month;

int main() {
    enum Color c = RED;
    printf("Color: %d\n", c);  // 0

    enum Status s = ACTIVE;
    printf("Status: %d\n", s);  // 0

    Month m = MARCH;
    printf("Month: %d\n", m);   // 3

    return 0;
}
```

### Использование enum в структурах
```c
#include <stdio.h>

typedef enum {
    STUDENT,
    TEACHER,
    ADMIN
} UserRole;

typedef struct {
    char name[50];
    UserRole role;
    int age;
} User;

void printUserRole(User *user) {
    switch (user->role) {
        case STUDENT:
            printf("%s is a Student\n", user->name);
            break;
        case TEACHER:
            printf("%s is a Teacher\n", user->name);
            break;
        case ADMIN:
            printf("%s is an Admin\n", user->name);
            break;
    }
}

int main() {
    User u1 = {"Alice", STUDENT, 20};
    User u2 = {"Bob", TEACHER, 35};

    printUserRole(&u1);
    printUserRole(&u2);

    return 0;
}
```

## 7. БИТОВЫЕ ПОЛЯ (BIT FIELDS)

### Основы битовых полей
```c
#include <stdio.h>

// Структура с битовыми полями (для экономии памяти)
struct Flags {
    unsigned int flag1 : 1;   // 1 бит
    unsigned int flag2 : 1;   // 1 бит
    unsigned int flag3 : 2;   // 2 бита
    unsigned int value : 4;   // 4 бита
};

int main() {
    struct Flags f;
    f.flag1 = 1;
    f.flag2 = 0;
    f.flag3 = 2;
    f.value = 5;

    printf("Size of struct Flags: %zu bytes\n", sizeof(struct Flags));  // 1 байт
    printf("flag1: %d\n", f.flag1);
    printf("flag3: %d\n", f.flag3);
    printf("value: %d\n", f.value);

    return 0;
}
```

### Использование битовых полей
```c
#include <stdio.h>

struct FilePermissions {
    unsigned int read : 1;     // Чтение
    unsigned int write : 1;    // Запись
    unsigned int execute : 1;  // Выполнение
};

int main() {
    struct FilePermissions perms;
    perms.read = 1;
    perms.write = 1;
    perms.execute = 0;

    printf("Size: %zu bytes\n", sizeof(struct FilePermissions));  // 1 байт

    if (perms.read) printf("Can read\n");
    if (perms.write) printf("Can write\n");
    if (perms.execute) printf("Can execute\n");

    return 0;
}
```

## 8. TYPEDEF И STRUCT

### typedef для структур
```c
#include <stdio.h>

// Способ 1: без typedef (требует 'struct' при объявлении)
struct Point1 {
    int x;
    int y;
};

// Способ 2: с typedef (не требует 'struct')
typedef struct {
    int x;
    int y;
} Point2;

// Способ 3: typedef с названием структуры
typedef struct Point3 {
    int x;
    int y;
} Point3;

int main() {
    struct Point1 p1 = {10, 20};              // Нужно писать 'struct'
    Point2 p2 = {30, 40};                     // Не нужно писать 'struct'
    Point3 p3 = {50, 60};                     // Не нужно писать 'struct'

    printf("P1: (%d, %d)\n", p1.x, p1.y);
    printf("P2: (%d, %d)\n", p2.x, p2.y);
    printf("P3: (%d, %d)\n", p3.x, p3.y);

    return 0;
}
```

## 9. ПРАКТИЧЕСКИЕ ПРИМЕРЫ

### Пример 1: Система управления контактами
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[50];
    char email[50];
    char phone[20];
} Contact;

typedef struct {
    Contact *contacts;
    int count;
    int capacity;
} ContactList;

ContactList *createContactList(int capacity) {
    ContactList *list = (ContactList *)malloc(sizeof(ContactList));
    list->contacts = (Contact *)malloc(capacity * sizeof(Contact));
    list->count = 0;
    list->capacity = capacity;
    return list;
}

void addContact(ContactList *list, const char *name,
                const char *email, const char *phone) {
    if (list->count >= list->capacity) {
        printf("Contact list is full!\n");
        return;
    }

    strcpy(list->contacts[list->count].name, name);
    strcpy(list->contacts[list->count].email, email);
    strcpy(list->contacts[list->count].phone, phone);
    list->count++;
}

void displayContacts(ContactList *list) {
    printf("\n--- Contact List ---\n");
    for (int i = 0; i < list->count; i++) {
        printf("%d. %s - %s - %s\n",
               i + 1,
               list->contacts[i].name,
               list->contacts[i].email,
               list->contacts[i].phone);
    }
}

void freeContactList(ContactList *list) {
    free(list->contacts);
    free(list);
}

int main() {
    ContactList *myList = createContactList(10);

    addContact(myList, "Alice", "alice@example.com", "123-456-7890");
    addContact(myList, "Bob", "bob@example.com", "098-765-4321");
    addContact(myList, "Charlie", "charlie@example.com", "111-222-3333");

    displayContacts(myList);

    freeContactList(myList);
    return 0;
}
```

### Пример 2: Система для работы с книгами
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int id;
    char title[100];
    char author[50];
    int year;
    float price;
} Book;

// Поиск книги по ID
Book *findBookById(Book *books, int size, int id) {
    for (int i = 0; i < size; i++) {
        if (books[i].id == id) {
            return &books[i];
        }
    }
    return NULL;
}

// Поиск книги по названию
Book *findBookByTitle(Book *books, int size, const char *title) {
    for (int i = 0; i < size; i++) {
        if (strcmp(books[i].title, title) == 0) {
            return &books[i];
        }
    }
    return NULL;
}

// Расчет общей стоимости
float calculateTotalValue(Book *books, int size) {
    float total = 0;
    for (int i = 0; i < size; i++) {
        total += books[i].price;
    }
    return total;
}

void displayBooks(Book *books, int size) {
    printf("\n--- Book Library ---\n");
    printf("%-4s %-30s %-20s %-6s %-8s\n", "ID", "Title", "Author", "Year", "Price");
    printf("------------------------------------------------------------------------------------\n");
    for (int i = 0; i < size; i++) {
        printf("%-4d %-30s %-20s %-6d $%-7.2f\n",
               books[i].id, books[i].title, books[i].author,
               books[i].year, books[i].price);
    }
}

int main() {
    Book library[] = {
        {1, "The C Programming Language", "Kernighan & Ritchie", 1988, 79.99},
        {2, "C: A Reference Manual", "Harbison & Steele", 2002, 89.99},
        {3, "Expert C Programming", "Peter van der Linden", 1994, 69.99},
        {4, "C Traps and Pitfalls", "Andrew Koenig", 1989, 54.99}
    };
    int n = 4;

    displayBooks(library, n);

    float totalValue = calculateTotalValue(library, n);
    printf("\nTotal Library Value: $%.2f\n", totalValue);

    Book *found = findBookByTitle(library, n, "Expert C Programming");
    if (found != NULL) {
        printf("Found: %s by %s ($%.2f)\n", found->title, found->author, found->price);
    }

    return 0;
}
```

### Пример 3: Система управления студентами
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int day;
    int month;
    int year;
} Date;

typedef struct {
    int id;
    char name[50];
    Date dateOfBirth;
    float cgpa;
    char major[50];
} Student;

int calculateAge(Date birth) {
    // Упрощённый расчет (не учитывает месяц и день)
    return 2025 - birth.year;
}

void displayStudent(Student *s) {
    printf("ID: %d\n", s->id);
    printf("Name: %s\n", s->name);
    printf("Date of Birth: %d/%d/%d\n", s->dateOfBirth.day,
           s->dateOfBirth.month, s->dateOfBirth.year);
    printf("Age: %d\n", calculateAge(s->dateOfBirth));
    printf("CGPA: %.2f\n", s->cgpa);
    printf("Major: %s\n", s->major);
    printf("---\n");
}

int main() {
    Student students[] = {
        {101, "Alice", {15, 5, 2003}, 3.8, "Computer Science"},
        {102, "Bob", {20, 8, 2004}, 3.5, "Engineering"},
        {103, "Charlie", {10, 3, 2003}, 3.9, "Computer Science"}
    };
    int n = 3;

    printf("=== Student Database ===\n\n");
    for (int i = 0; i < n; i++) {
        displayStudent(&students[i]);
    }

    return 0;
}
```

## 10. ТИПИЧНЫЕ ОШИБКИ СО СТРУКТУРАМИ

### Ошибка 1: Забыли инициализировать структуру
```c
// ❌ НЕПРАВИЛЬНО:
struct Point p;
printf("%d\n", p.x);  // Мусор! Неинициализировано

// ✅ ПРАВИЛЬНО:
struct Point p = {0, 0};
printf("%d\n", p.x);  // 0
```

### Ошибка 2: Неправильное использование struct/union
```c
// ❌ НЕПРАВИЛЬНО: забыли 'struct'
Point p = {10, 20};  // Ошибка компиляции (если нет typedef)

// ✅ ПРАВИЛЬНО:
struct Point p = {10, 20};

// ✅ ИЛИ: используйте typedef
typedef struct {
    int x, y;
} Point;
Point p = {10, 20};
```

### Ошибка 3: Сравнение структур с ==
```c
// ❌ НЕПРАВИЛЬНО: не работает как ожидается
struct Point p1 = {10, 20};
struct Point p2 = {10, 20};
if (p1 == p2) {  // Может НЕ работать как ожидается!
    printf("Equal\n");
}

// ✅ ПРАВИЛЬНО: сравнивайте члены
if (p1.x == p2.x && p1.y == p2.y) {
    printf("Equal\n");
}

// ✅ ИЛИ: используйте memcmp
if (memcmp(&p1, &p2, sizeof(struct Point)) == 0) {
    printf("Equal\n");
}
```

### Ошибка 4: Забыли освободить динамическую структуру
```c
// ❌ НЕПРАВИЛЬНО: утечка памяти
struct Point *p = (struct Point *)malloc(sizeof(struct Point));
// Забыли free(p);

// ✅ ПРАВИЛЬНО:
struct Point *p = (struct Point *)malloc(sizeof(struct Point));
if (p != NULL) {
    // Используем p...
    free(p);
    p = NULL;
}
```

### Ошибка 5: Выравнивание структур (padding)
```c
// ⚠️ ВНИМАНИЕ: размер может быть больше, чем вы думаете

struct Example {
    char c;        // 1 байт + 3 байта padding
    int i;         // 4 байта (выравнено на границе 4 байт)
    double d;      // 8 байт
};
// Размер: 1 + 3 + 4 + 8 = 16 байт (не 13!)

// Для минимизации padding:
struct OptimizedExample {
    double d;      // 8 байт
    int i;         // 4 байта
    char c;        // 1 байт + 3 байта padding
};
// Размер: всё равно 16 байт, но более логично
```

### Ошибка 6: Передача больших структур вместо указателя
```c
// ❌ НЕПРАВИЛЬНО: копируется вся структура (медленно)
void processLargeStruct(struct LargeData data) {
    // data — локальная копия
}

// ✅ ПРАВИЛЬНО: передача указателя (быстро)
void processLargeStruct(const struct LargeData *data) {
    // data — указатель
}
```

## 11. ОПТИМИЗАЦИЯ И BEST PRACTICES

### Правильное определение структур
```c
// ✅ ХОРОШО: используйте typedef для удобства
typedef struct {
    char name[50];
    int age;
    float salary;
} Employee;

Employee e1 = {"Alice", 30, 50000.0};  // Не нужно писать 'struct'

// ✅ ХОРОШО: упорядочивайте члены по размеру (минимизирует padding)
typedef struct {
    double salary;      // 8 байт
    char name[50];      // 50 байт
    int age;            // 4 байта
    char status;        // 1 байт
} Employee2;

// ❌ ПЛОХО: случайный порядок членов
typedef struct {
    char status;        // 1 байт + 3 padding
    double salary;      // 8 байт
    int age;            // 4 байта
    char name[50];      // 50 байт
} Employee3;
```

### Функции для работы со структурами
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[50];
    int id;
} User;

// ✅ ХОРОШАЯ ПРАКТИКА: выделение
User *createUser(const char *name, int id) {
    User *u = (User *)malloc(sizeof(User));
    if (u != NULL) {
        strcpy(u->name, name);
        u->id = id;
    }
    return u;
}

// ✅ ХОРОШАЯ ПРАКТИКА: копирование
User *duplicateUser(const User *original) {
    if (original == NULL) return NULL;
    User *copy = (User *)malloc(sizeof(User));
    if (copy != NULL) {
        *copy = *original;  // Копируем всю структуру
    }
    return copy;
}

// ✅ ХОРОШАЯ ПРАКТИКА: освобождение
void deleteUser(User *u) {
    if (u != NULL) {
        free(u);
    }
}
```

## КЛЮЧЕВЫЕ МОМЕНТЫ

✅ Структуры объединяют разные типы данных в один тип
✅ ВСЕГДА инициализируйте структуры перед использованием
✅ Используйте typedef для упрощения синтаксиса
✅ Передавайте большие структуры через указатели
✅ Помните о выравнивании (padding) при расчете размера
✅ ВСЕГДА освобождайте динамические структуры
✅ Используйте вложенные структуры для сложных данных
✅ Используйте enum для перечислений значений
✅ Используйте union для вариантных типов данных
✅ Сравнивайте члены структур отдельно, не используйте ==
✅ Битовые поля экономят память для булевых флагов
✅ Упорядочивайте члены структуры по размеру для минимизации padding
✅ Документируйте структуры и их члены
✅ Используйте const для структур, которые не меняются
✅ Проверяйте NULL при работе с указателями на структуры
