ПЕРЕМЕННЫЕ И ТИПЫ ДАННЫХ В ПРОГРАММИРОВАНИИ

================================================================================
1. ОСНОВНЫЕ ПОНЯТИЯ
================================================================================

1.1 ЧТО ТАКОЕ ПЕРЕМЕННАЯ

Определение: Переменная - это именованная ячейка памяти, которая хранит значение определённого типа данных и может изменять своё значение во время выполнения программы.

Ключевые характеристики:
- Имя (идентификатор): уникальное имя переменной в пределах области видимости
- Тип данных: определяет размер памяти и допустимые операции
- Значение: данные, хранящиеся в переменной
- Адрес в памяти: место, где хранятся данные
- Область видимости: часть программы, где переменная доступна

Пример на C:
int age = 25;  // переменная с именем age, типом int, значением 25

---

1.2 ОБЪЯВЛЕНИЕ И ИНИЦИАЛИЗАЦИЯ

Объявление: Процесс создания переменной с указанием типа и имени.
- Резервирует место в памяти
- Связывает имя с адресом памяти
- Не гарантирует начальное значение (может содержать мусор)

Инициализация: Процесс присваивания переменной начального значения при объявлении.

Пример:
int x;           // объявление (значение неопределено)
x = 10;          // присваивание
int y = 20;      // объявление с инициализацией

---

1.3 ПРАВИЛА ИМЕНОВАНИЯ ПЕРЕМЕННЫХ В C

- Начинаться должна с буквы (a-z, A-Z) или подчёркивания (_)
- Содержать буквы, цифры (0-9) и подчёркивание
- Чувствительна к регистру (age ≠ Age ≠ AGE)
- Не может быть зарезервированным словом (int, if, while и т.д.)
- Рекомендуется использовать snake_case или camelCase

Валидные примеры: age, user_name, _private, value123

Невалидные примеры: 123age (начинается с цифры), user-name (дефис запрещен), int (зарезервированное слово)

================================================================================
2. ТИПЫ ДАННЫХ В C
================================================================================

2.1 ЦЕЛОЧИСЛЕННЫЕ ТИПЫ

--- char ---

Размер: 1 байт (8 бит)
Диапазон: от -128 до 127 (signed) или 0 до 255 (unsigned)
Использование: Для хранения одного символа или небольших целых чисел

Пример:
char letter = 'A';      // символ
char ascii_value = 65;  // число (эквивалент 'A')

Важно: Символы хранятся как ASCII коды (числовые значения)

--- int ---

Размер: Обычно 4 байта (32 бита), но может быть 2 или 8 байт
Диапазон: от -2,147,483,648 до 2,147,483,647 (для 32-бит signed)
Использование: Базовый тип для целых чисел, наиболее часто используемый

Пример:
int count = 100;
int temperature = -15;
int population = 8000000;

--- short ---

Размер: Минимум 2 байта (16 бит)
Диапазон: от -32,768 до 32,767 (для signed)
Использование: Когда важна экономия памяти

Пример:
short year_offset = 1900;

--- long ---

Размер: Минимум 4 байта, часто 8 байт на 64-битных системах
Диапазон: от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807 (для 64-бит signed)
Использование: Для очень больших целых чисел

Пример:
long large_number = 9000000000L;  // суффикс L указывает на long

--- unsigned ---

Определение: Версия целочисленного типа только с положительными значениями
Эффект: Увеличивает верхний предел в два раза, нижний предел = 0

Примеры:
unsigned int positive = 4294967295;  // максимальное значение для unsigned int
unsigned char byte = 255;
unsigned short count = 65535;
unsigned long big = 18446744073709551615UL;

ТАБЛИЦА ЦЕЛОЧИСЛЕННЫХ ТИПОВ:

Тип     | Размер    | Диапазон (signed)           | Диапазон (unsigned)
--------|-----------|---------------------------|----------------------
char    | 1 байт    | -128 до 127              | 0 до 255
short   | 2+ байта  | -32,768 до 32,767        | 0 до 65,535
int     | 4+ байта  | -2.1 млрд до 2.1 млрд   | 0 до 4.3 млрд
long    | 4+ байта  | ≤ -9.2 квинтильона      | ≤ 18.4 квинтильона

---

2.2 ТИПЫ С ПЛАВАЮЩЕЙ ТОЧКОЙ

--- float ---

Размер: 4 байта (32 бита)
Точность: Примерно 6-7 значащих цифр
Диапазон: Примерно ±1.17549e-38 до ±3.40282e+38
Использование: Для чисел с десятичной частью, когда не требуется высокая точность

Пример:
float pi = 3.14159f;  // суффикс f указывает на float
float temperature = 98.6f;

Важно: По умолчанию буквальные значения типа 3.14 интерпретируются как double, поэтому используется суффикс f

--- double ---

Размер: 8 байт (64 бита)
Точность: Примерно 15-16 значащих цифр
Диапазон: Примерно ±2.22507e-308 до ±1.79769e+308
Использование: Тип по умолчанию для чисел с плавающей точкой, рекомендуется для научных расчётов

Пример:
double pi = 3.141592653589793;
double gravity = 9.81;  // без суффикса - по умолчанию double

--- long double ---

Размер: 8, 10 или 16 байт (зависит от реализации)
Точность: Минимум столько же, сколько double, часто больше
Использование: Для расчётов, требующих максимальной точности

Пример:
long double pi = 3.141592653589793238L;

ТАБЛИЦА ТИПОВ С ПЛАВАЮЩЕЙ ТОЧКОЙ:

Тип         | Размер    | Точность     | Минимум        | Максимум
------------|-----------|--------------|----------------|------------------
float       | 4 байта   | 6-7 цифр    | ±1.17e-38     | ±3.40e+38
double      | 8 байт    | 15-16 цифр  | ±2.22e-308    | ±1.79e+308
long double | 8-16 байт | 15+ цифр    | еще меньше    | еще больше

---

2.3 БУЛЕВ ТИП (В C99 СТАНДАРТЕ)

--- _Bool (или bool с заголовком stdbool.h) ---

Размер: 1 байт
Возможные значения: 0 (false) или 1 (true)
Использование: Для логических значений, результатов сравнений

Пример:
#include <stdbool.h>
bool is_active = true;
bool is_empty = false;

Важно: До C99 использовались int или char для логических значений

---

2.4 ПРОИЗВОДНЫЕ ТИПЫ

--- Массивы ---

Определение: Совокупность элементов одного типа, расположенных подряд в памяти

Пример:
int numbers[5] = {10, 20, 30, 40, 50};  // массив из 5 целых чисел
char name[20];  // массив из 20 символов (строка)

--- Указатели ---

Определение: Переменная, хранящая адрес памяти другой переменной

Пример:
int x = 10;
int *ptr = &x;  // ptr содержит адрес x

--- Структуры ---

Определение: Пользовательский тип, объединяющий несколько переменных разных типов

Пример:
struct Person {
    char name[50];
    int age;
    float height;
};

--- Объединения ---

Определение: Подобно структуре, но все члены занимают одно и то же место в памяти

Пример:
union Data {
    int i;
    float f;
    char c;  // все три переменные используют один и тот же байт-блок
};

--- Перечисления ---

Определение: Тип данных, состоящий из набора именованных целочисленных констант

Пример:
enum Color { RED = 0, GREEN = 1, BLUE = 2 };
enum Color my_color = GREEN;

================================================================================
3. СПЕЦИФИКАТОРЫ ТИПОВ
================================================================================

3.1 SIGNED И UNSIGNED

signed: Тип может принимать как положительные, так и отрицательные значения
unsigned: Тип может принимать только неотрицательные значения

Сравнение:
signed int x = -10;      // может быть отрицательным
unsigned int y = 10;     // только положительное
// unsigned int z = -10;  // ошибка: присваивание отрицательного значения unsigned

По умолчанию: Целочисленные типы - signed, кроме случаев, когда явно указано unsigned

---

3.2 CONST

Определение: Указывает, что переменная не может быть изменена после инициализации

Пример:
const int max_users = 100;  // max_users не может быть изменена
const float PI = 3.14159f;
// max_users = 50;  // ошибка компиляции

Использование: Для фиксирования значений, которые не должны меняться

---

3.3 VOLATILE

Определение: Указывает компилятору, что значение может измениться неожиданно (например, из-за внешних факторов)

Пример:
volatile int sensor_reading;  // может измениться извне программы

Использование: Для переменных, связанных с аппаратным обеспечением или многопоточностью

---

3.4 STATIC

Определение: Переменная сохраняет значение между вызовами функции или видима только в пределах файла

Пример:
void increment() {
    static int count = 0;  // инициализируется один раз
    count++;
    printf("%d\n", count);  // 1, 2, 3, ... при каждом вызове
}

================================================================================
4. ПРЕОБРАЗОВАНИЕ ТИПОВ
================================================================================

4.1 НЕЯВНОЕ ПРЕОБРАЗОВАНИЕ (IMPLICIT CASTING)

Определение: Автоматическое преобразование типа, выполняемое компилятором

Правила:
- char → int → long → float → double
- int → float (может привести к потере точности)
- float → double (всегда безопасно)

Пример:
int x = 10;
float y = x;  // x автоматически преобразуется в 10.0
double z = y;  // y преобразуется в 10.0

Риск: Может привести к потере информации (например, при преобразовании double в int теряется дробная часть)

---

4.2 ЯВНОЕ ПРЕОБРАЗОВАНИЕ (EXPLICIT CASTING)

Определение: Явное указание преобразования типа с помощью оператора (тип)

Синтаксис:
(новый_тип) выражение

Примеры:
double pi = 3.14159;
int rounded = (int)pi;  // rounded = 3 (дробная часть отбрасывается)

int x = 65;
char c = (char)x;  // c = 'A' (ASCII код)

float f = (float)100 / 3;  // f = 33.333... (деление в float)

Важно: Явное преобразование может привести к потере данных и ошибкам, если не использовать осторожно

---

4.3 ПРИОРИТЕТ ПРИ СМЕШАННЫХ ОПЕРАЦИЯХ

Когда в одном выражении участвуют разные типы:
1. char и short → int
2. Если int и long → long
3. Если какой-то операнд float → float
4. Если какой-то операнд double → double
5. Если какой-то операнд long double → long double

Пример:
int x = 5;
float y = 2.5;
float result = x + y;  // x преобразуется в float, результат float

================================================================================
5. ОБЛАСТЬ ВИДИМОСТИ (SCOPE) И ВРЕМЯ ЖИЗНИ ПЕРЕМЕННЫХ
================================================================================

5.1 ОБЛАСТЬ ВИДИМОСТИ (SCOPE)

--- Локальная область видимости ---

Определение: Переменная видна только в блоке (функции, цикле, условии), где она объявлена

Пример:
void function() {
    int local_var = 10;  // видна только внутри function
    {
        int inner_var = 20;  // видна только внутри этого блока
    }
    // printf("%d", inner_var);  // ошибка: inner_var не видна
}
// printf("%d", local_var);  // ошибка: local_var не видна

--- Глобальная область видимости ---

Определение: Переменная видна во всем файле и может быть доступна в других файлах (при extern)

Пример:
int global_var = 100;  // видна везде в программе

void function() {
    printf("%d", global_var);  // доступна
}

--- Область видимости блока ---

Определение: Переменная видна с момента объявления до конца блока {}

Пример:
{
    int x = 10;
    // x видна здесь
}
// x не видна здесь

---

5.2 ВРЕМЯ ЖИЗНИ ПЕРЕМЕННЫХ

--- Локальные переменные (Stack) ---

Время жизни: От объявления до конца блока
Место хранения: Стек (Stack)
Характеристики: Быстрый доступ, память автоматически освобождается

Пример:
void foo() {
    int x = 5;  // создается при входе в функцию
    // x существует до конца функции
}  // x удаляется здесь

--- Глобальные переменные (Data/BSS) ---

Время жизни: От запуска программы до завершения
Место хранения: Сегмент данных (Data) или неинициализированный сегмент (BSS)
Характеристики: Существуют всю программу, инициализируются при запуске

--- Динамические переменные (Heap) ---

Время жизни: От malloc/calloc до free
Место хранения: Куча (Heap)
Характеристики: Требуют явного освобождения, медленнее, чем Stack

Пример:
int *ptr = malloc(sizeof(int));  // выделяется память на Heap
*ptr = 10;
free(ptr);  // память освобождается, когда больше не нужна

--- Статические переменные ---

Время жизни: От запуска программы до завершения
Место хранения: Сегмент данных
Характеристики: Инициализируются один раз, сохраняют значение между вызовами

Пример:
void counter() {
    static int count = 0;  // инициализируется один раз
    count++;
}

================================================================================
6. РАЗМЕР ТИПОВ ДАННЫХ
================================================================================

6.1 ОПЕРАТОР SIZEOF

Определение: Возвращает размер типа или переменной в байтах

Синтаксис:
sizeof(тип)     // размер типа
sizeof(переменная)  // размер переменной

Примеры:
printf("Размер int: %lu байт\n", sizeof(int));       // обычно 4
printf("Размер float: %lu байт\n", sizeof(float));   // обычно 4
printf("Размер double: %lu байт\n", sizeof(double)); // обычно 8
printf("Размер char: %lu байт\n", sizeof(char));     // всегда 1

int x = 10;
printf("Размер x: %lu байт\n", sizeof(x));  // 4

---

6.2 ЗАВИСИМОСТЬ ОТ ПЛАТФОРМЫ

Важно: Размеры типов зависят от компилятора и платформы

Гарантии стандарта C:
- sizeof(char) == 1
- sizeof(short) ≤ sizeof(int)
- sizeof(int) ≤ sizeof(long)
- sizeof(long) ≤ sizeof(long long)

Проверка размеров:
#include <stdio.h>
#include <limits.h>

printf("INT_MAX: %d\n", INT_MAX);
printf("INT_MIN: %d\n", INT_MIN);

================================================================================
7. ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
================================================================================

7.1 ЛОКАЛЬНАЯ ИНИЦИАЛИЗАЦИЯ

Без инициализации: Переменная содержит мусорные данные (неопределённое значение)

Пример:
int x;  // x содержит произвольное значение
printf("%d\n", x);  // undefined behavior

С инициализацией: Переменной присваивается начальное значение

Пример:
int x = 0;  // x инициализирована нулём

---

7.2 ГЛОБАЛЬНАЯ ИНИЦИАЛИЗАЦИЯ

По умолчанию: Глобальные переменные инициализируются нулями

Пример:
int global_x;  // инициализирована 0
float global_f;  // инициализирована 0.0
char global_c;  // инициализирована '\0'

---

7.3 ИНИЦИАЛИЗАЦИЯ МАССИВОВ

int arr1[5] = {1, 2, 3, 4, 5};  // все элементы указаны
int arr2[5] = {1, 2};  // остальные элементы = 0
int arr3[] = {1, 2, 3};  // размер выводится из инициализации (3)
int arr4[5] = {};  // все элементы = 0

---

7.4 ИНИЦИАЛИЗАЦИЯ СТРУКТУР

struct Point {
    int x;
    int y;
};

struct Point p1 = {10, 20};  // обозначенная инициализация
struct Point p2 = {.x = 10, .y = 20};  // именованная инициализация (C99)

================================================================================
8. ЛУЧШИЕ ПРАКТИКИ
================================================================================

8.1 ВЫБОР ПРАВИЛЬНОГО ТИПА

- Целые числа: Используйте int, если диапазон неизвестен
- Большие числа: long или long long для чисел > 2 млрд
- Маленькие числа: char или short, если важна память
- Точные вычисления: double для финансовых и научных расчётов
- Быстрые приближённые вычисления: float если нужна скорость

---

8.2 ИНИЦИАЛИЗАЦИЯ

- Всегда инициализируйте локальные переменные, особенно при работе с указателями
- Используйте константы для фиксированных значений
- Проверяйте диапазоны перед преобразованием типов

---

8.3 ИМЕНОВАНИЕ

- Используйте осмысленные имена: user_age лучше, чем ua
- Следуйте соглашениям: snake_case для C, camelCase для C++
- Избегайте однобуквенных имён, кроме счётчиков циклов

---

8.4 ИЗБЕГАНИЕ ОШИБОК

- Целочисленное переполнение: Проверяйте границы диапазонов
- Потеря точности: Осторожнее с неявным преобразованием float → int
- Неинициализированные переменные: Всегда инициализируйте перед использованием
- Утечки памяти: Освобождайте динамическую память с помощью free()

================================================================================
9. ПРАКТИЧЕСКИЕ ПРИМЕРЫ
================================================================================

9.1 ПРИМЕР 1: РАБОТА С РАЗНЫМИ ТИПАМИ

#include <stdio.h>

int main() {
    // Целочисленные типы
    char symbol = 'A';
    short small_number = 100;
    int count = 50000;
    long big_number = 1000000000L;
    
    // Типы с плавающей точкой
    float temperature = 36.6f;
    double pi = 3.141592653589793;
    
    // Булев тип
    int is_valid = 1;  // или используйте bool с stdbool.h
    
    // Вывод информации о типах
    printf("Размер char: %lu\n", sizeof(char));
    printf("Размер int: %lu\n", sizeof(int));
    printf("Размер double: %lu\n", sizeof(double));
    
    // Преобразование типов
    int x = (int)temperature;  // x = 36
    
    return 0;
}

---

9.2 ПРИМЕР 2: ВЫЧИСЛЕНИЕ ПЛОЩАДИ КРУГА

#include <stdio.h>
#define PI 3.141592653589793

int main() {
    const float radius = 5.0f;  // радиус - константа
    float area = PI * radius * radius;
    
    printf("Радиус: %.1f\n", radius);
    printf("Площадь: %.2f\n", area);
    
    return 0;
}

---

9.3 ПРИМЕР 3: РАБОТА С CHAR И ASCII

#include <stdio.h>

int main() {
    char c = 'A';  // символ 'A' (ASCII 65)
    int ascii = (int)c;  // преобразование в число
    
    printf("Символ: %c\n", c);  // выведет: A
    printf("ASCII код: %d\n", ascii);  // выведет: 65
    
    // Обратное преобразование
    char letter = (char)66;  // ASCII 66 = 'B'
    printf("Символ по коду 66: %c\n", letter);  // выведет: B
    
    return 0;
}

---

9.4 ПРИМЕР 4: РАБОТА СО СТАТИЧЕСКИМИ ПЕРЕМЕННЫМИ

#include <stdio.h>

void increment() {
    static int count = 0;  // инициализируется один раз
    count++;
    printf("Вызов номер: %d\n", count);
}

int main() {
    increment();  // выведет: 1
    increment();  // выведет: 2
    increment();  // выведет: 3
    
    return 0;
}

================================================================================
10. ТАБЛИЦА СРАВНЕНИЯ ТИПОВ ДАННЫХ
================================================================================

Тип        | Размер  | Диапазон              | Точность  | Использование
-----------|---------|----------------------|-----------|----------------------------
char       | 1 b     | -128...127           | N/A       | Символы, маленькие числа
short      | 2+ b    | -32k...32k           | N/A       | Малые целые числа
int        | 4+ b    | -2.1M...2.1M         | N/A       | Общего назначения
long       | 4+ b    | > 2.1M               | N/A       | Большие целые числа
long long  | 8 b     | > 9Q                 | N/A       | Очень большие числа
float      | 4 b     | ±1.17e-38...±3.4e+38 | 6-7       | Быстрые расчёты
double     | 8 b     | ±2.22e-308...±1.79e+308 | 15-16   | Научные расчёты
long double| 8-16 b  | еще шире             | 15+       | Максимальная точность
bool       | 1 b     | 0 или 1              | N/A       | Логические значения

================================================================================
11. ЗАДАНИЯ ДЛЯ ПРОВЕРКИ ПОНИМАНИЯ
================================================================================

11.1 ВОПРОСЫ НА ПОНИМАНИЕ

Вопрос 1: Какой размер в байтах имеет тип int на большинстве современных систем?
Ответ: 4 байта

Вопрос 2: Что произойдёт, если присвоить отрицательное число переменной типа unsigned int?
Ответ: Компилятор выдаст предупреждение или ошибку; значение будет интерпретировано как очень большое положительное число

Вопрос 3: Чем отличается double от float по точности?
Ответ: double имеет примерно 15-16 значащих цифр, float имеет примерно 6-7 значащих цифр

Вопрос 4: Какое значение содержит неинициализированная локальная переменная?
Ответ: Неопределённое значение (мусор), что является undefined behavior

Вопрос 5: Как долго существует статическая переменная?
Ответ: От запуска программы до её завершения, сохраняя значение между вызовами функции

---

11.2 ПРАКТИЧЕСКИЕ ЗАДАЧИ

Задача 1: Напишите программу, которая вычисляет произведение двух целых чисел и выводит результат.
Ключевые концепции: Объявление переменных int, присваивание, операции, вывод

Задача 2: Создайте программу для преобразования температуры из Цельсия в Фаренгейт (F = C * 9/5 + 32).
Ключевые концепции: float для точных расчётов, преобразование типов, математические операции

Задача 3: Напишите функцию, которая демонстрирует разницу между signed и unsigned int.
Ключевые концепции: signed/unsigned типы, переполнение, диапазоны значений

Задача 4: Создайте программу с глобальной и локальной переменной одного имени и продемонстрируйте область видимости.
Ключевые концепции: Глобальная и локальная область видимости, приоритет локальной переменной

Задача 5: Напишите программу, которая использует sizeof() для определения размера всех основных типов данных.
Ключевые концепции: sizeof(), размеры типов, зависимость от платформы

================================================================================
РЕЗЮМЕ КЛЮЧЕВЫХ КОНЦЕПЦИЙ
================================================================================

1. Переменная - именованное хранилище для данных определённого типа
2. Базовые типы: char, int, float, double
3. Производные типы: массивы, указатели, структуры, объединения, перечисления
4. Спецификаторы: signed/unsigned, const, volatile, static
5. Преобразование типов: неявное (автоматическое) и явное (с оператором cast)
6. Область видимости: локальная, глобальная, блоку
7. Время жизни: зависит от места объявления (stack/heap/data segment)
8. Инициализация: важна для избежания undefined behavior
9. sizeof() - инструмент для проверки размеров типов
10. Лучшие практики: выбирайте правильные типы, инициализируйте переменные, используйте осмысленные имена

================================================================================
Конец документа
================================================================================